<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Note Secretary â€“ DroidScript Backend</title>
<link rel="stylesheet" href="common.css">
<link rel="stylesheet" href="style.css">
</head>
<body>
<div class="app">
  <header>
    <button id="menuBtn">â˜°</button>
    <div class="spacer"></div>
    <div class="connection-status">
      <span class="connection-led" id="statusLed"></span>
      <span id="statusText">Connecting...</span>
    </div>
    <select id="lang">
      <option value="en-US">English</option>
      <option value="he-IL">×¢×‘×¨×™×ª</option>
    </select>
    <button id="clearBtn" class="secondary" title="Clear chat messages">ğŸ—‘ï¸</button>
  </header>

  <p class="warn" id="tipSection">Tip: Try compact commands like <code>/createnote groceries</code> or <code>/findnote groceries</code>. For editing: <code>/findnote groceries</code> then <code>/editdescription</code>. To see all notes: <code>/showparents</code>. Speech works via the browser's Web Speech API. Gemini here is for **testing only**â€”your key is exposed.</p>

  <div id="log"></div>

  <form id="chat">
    <textarea id="input" placeholder="Type a messageâ€¦"></textarea>
    <button class="primary" type="submit">Send</button>
  </form>
  
  <div class="row" style="padding: 8px 16px; border-top: 1px solid #222;">
    <button id="helpBtn" class="secondary">Commands</button>
    <button id="micBtn" title="Speech to text">ğŸ¤ Speak</button>
    <label><input type="checkbox" id="useTTS"> ğŸ”Š Read responses</label>
  </div>
</div>

<!-- Upload Modal -->
<div id="uploadModal" class="upload-modal">
  <div class="upload-content">
    <div class="upload-header">
      <h3>Upload Images</h3>
      <button class="upload-close" onclick="closeUploadModal()">&times;</button>
    </div>
            <div class="upload-body">
              <div class="upload-area" onclick="selectImages()">
                <div class="upload-icon">ğŸ“·</div>
                <div class="upload-text">Click to select images</div>
                <div class="upload-hint">Supports JPG, PNG, GIF (max 5 images)</div>
              </div>
              
              
              
      <input type="file" id="fileInput" class="file-input" multiple accept="image/*" style="display: none;">
      <div id="previewContainer" class="preview-container"></div>
              <div class="upload-buttons">
                <button class="cancel-btn" onclick="closeUploadModal()">Cancel</button>
                <button class="upload-btn" id="uploadBtn" onclick="uploadImages()" disabled>Upload</button>
              </div>
    </div>
  </div>
</div>

<!-- Commands Popup -->
<div class="overlay" id="commandsOverlay"></div>
<div class="commands-popup" id="commandsPopup">
  <div class="commands-header">
    <h3>Quick Commands</h3>
    <button id="closeCommands">âœ•</button>
  </div>
  <div class="commands-content" id="commandsContent">
    <!-- Commands will be populated dynamically based on current mode -->
  </div>
</div>

<!-- Side Menu -->
<div class="overlay" id="overlay"></div>
<div class="side-menu" id="sideMenu">
  <div class="side-menu-header">
    <h2>Settings</h2>
    <button id="closeMenu">âœ•</button>
  </div>
  <div class="side-menu-content">
    <h3>Navigation</h3>
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:20px;">
      <button id="chatButton" class="nav-button active">ğŸ’¬ Chat</button>
      <button id="explorerButton" class="nav-button secondary">ğŸ“ Note Explorer</button>
      <button id="settingsButton" class="nav-button secondary">âš™ï¸ Settings</button>
    </div>
    

  </div>
</div>

<!-- Load shared WebSocket client -->
<script src="shared-websocket.js"></script>

<script>
/* ---------- Settings ---------- */
const Settings = { 
  lang: "en",
  geminiApiKey: "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4", // Default API key
  autoConfirm: false
};

// Global variables
let currentNoteId = null;
let selectedFiles = [];



/* ---------- UI wiring ---------- */
const logEl   = document.getElementById("log");
const inputEl = document.getElementById("input");
const formEl  = document.getElementById("chat");
const langSel = document.getElementById("lang");
const clearBtn= document.getElementById("clearBtn");
const micBtn  = document.getElementById("micBtn");
const useTTS  = document.getElementById("useTTS");
const menuBtn = document.getElementById("menuBtn");
const sideMenu = document.getElementById("sideMenu");
const overlay = document.getElementById("overlay");
const closeMenu = document.getElementById("closeMenu");

const chatButton = document.getElementById("chatButton");
const explorerButton = document.getElementById("explorerButton");
const settingsButton = document.getElementById("settingsButton");
const helpBtn = document.getElementById("helpBtn");
const commandsPopup = document.getElementById("commandsPopup");
const commandsOverlay = document.getElementById("commandsOverlay");
const closeCommands = document.getElementById("closeCommands");
const commandsContent = document.getElementById("commandsContent");

let availableCommands = [];
let commandsLoaded = false;
let commandHistory = [];
const MAX_COMMAND_HISTORY = 10;

function addToCommandHistory(command) {
  commandHistory = commandHistory.filter(cmd => cmd !== command);
  commandHistory.unshift(command);
  if (commandHistory.length > MAX_COMMAND_HISTORY) {
    commandHistory = commandHistory.slice(0, MAX_COMMAND_HISTORY);
  }
  localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
}

function loadCommandHistory() {
  const saved = localStorage.getItem('commandHistory');
  if (saved) {
    try { commandHistory = JSON.parse(saved); } catch (e) { commandHistory = []; }
  }
}

function getCommandHistory() { return commandHistory; }

function updateConnectionStatus(connected) {
  const statusLed = document.getElementById('statusLed');
  const statusText = document.getElementById('statusText');
  if (!statusLed || !statusText) return;
  if (connected) {
    statusLed.className = 'connection-led connected';
    statusText.textContent = 'Connected';
  } else {
    statusLed.className = 'connection-led disconnected';
    statusText.textContent = 'Connecting...';
  }
}

function loadAvailableCommands() {
  SharedWebSocket.send({type: 'get_commands'});
}

function generateDynamicCommands() {
  if (availableCommands.length === 0) return '<div class="command-category"><h4>âŒ No commands available</h4></div>';
  const categories = {};
  availableCommands.forEach(cmd => {
    if (!categories[cmd.category]) categories[cmd.category] = [];
    categories[cmd.category].push(cmd);
  });
  let html = '';
  for (const category in categories) {
    html += `<div class="command-category"><h4>${category}</h4>`;
    categories[category].forEach(cmd => {
      const commandText = cmd.requiresParam ? cmd.command + ' ' : cmd.command;
      let buttonText = cmd.command;
      if (cmd.description) buttonText += ` <span style="opacity: 0.6; font-size: 0.85em; font-style: italic;">[${cmd.description}]</span>`;
      if (cmd.requiresParam && cmd.examples && cmd.examples.length > 0) buttonText += ` <span style="opacity: 0.7; font-size: 0.9em;">(${cmd.examples[0]})</span>`;
      html += `<button class="command-btn" data-command="${commandText}">${buttonText}</button>`;
    });
    html += `</div>`;
  }
  return html;
}

function updateModeFromMessage(message) {
  if (message.includes("What would you like to do?") || message.includes("cancelled")) {
    loadAvailableCommands();
  }
}

langSel.onchange = () => {
  Settings.lang = langSel.value;
  document.documentElement.dir = (Settings.lang === "he") ? "rtl" : "ltr";
};
clearBtn.onclick = () => { 
  if (confirm("Are you sure you want to clear all chat messages?")) {
    logEl.innerHTML = ""; 
    clearChatHistory();
    addMsg("ğŸ—‘ï¸ Chat messages cleared", "sys");
  }
};

function populateCommands() {
  commandsContent.innerHTML = '';
  const history = getCommandHistory();
  if (history.length > 0) {
    let historyHtml = `<div class="command-category"><h4>ğŸ•’ Recent Commands</h4>`;
    for (let i = 0; i < Math.min(history.length, 5); i++) {
      historyHtml += `<button class="command-btn" data-command="${history[i]}">${history[i]}</button>`;
    }
    historyHtml += `</div>`;
    commandsContent.innerHTML += historyHtml;
  }
  if (commandsLoaded && availableCommands.length > 0) {
    commandsContent.innerHTML += generateDynamicCommands();
  } else {
    commandsContent.innerHTML += `<div class="command-category"><h4>âŒ No commands available</h4><p>Loading...</p></div>`;
  }
}

helpBtn.onclick = () => {
  populateCommands();
  commandsPopup.classList.add("show");
  commandsOverlay.classList.add("show");
};

closeCommands.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};

commandsOverlay.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};

document.addEventListener('click', (e) => {
  const commandButton = e.target.closest('.command-btn');
  if (commandButton) {
    const command = commandButton.getAttribute('data-command');
    if (command) {
      inputEl.value = command;
      addToCommandHistory(command);
      commandsPopup.classList.remove("show");
      commandsOverlay.classList.remove("show");
      inputEl.focus();
      inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
      e.preventDefault();
      e.stopPropagation();
    }
  }
});

menuBtn.onclick = () => {
  sideMenu.classList.add("open");
  overlay.classList.add("show");
};

closeMenu.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

overlay.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

function navigateToPage(page) {
  window.location.href = page;
}

chatButton.onclick = () => navigateToPage('index.html');
explorerButton.onclick = () => navigateToPage('explorer.html');
settingsButton.onclick = () => navigateToPage('settings.html');



/* ---------- Service Worker and WebSocket Logic ---------- */
function sendToWorker(messageObject) {
    SharedWebSocket.send(messageObject);
}

function initializeServiceWorker() {
    // Use shared WebSocket instead of direct service worker communication
    SharedWebSocket.registerHandler('ws_open', (data) => {
        updateConnectionStatus(true);
        loadAvailableCommands();
        handleUrlParameters();
        const savedNoteId = localStorage.getItem('currentNoteId');
        if (savedNoteId) SharedWebSocket.send({ type: 'restore_context', noteId: savedNoteId });
    });
    
    SharedWebSocket.registerHandler('ws_close', (data) => {
        updateConnectionStatus(false);
    });
    
    SharedWebSocket.registerHandler('ws_error', (data) => {
        updateConnectionStatus(false);
        addMsg("Connection error.", "sys");
    });
    
    SharedWebSocket.registerHandler('reply', (data) => {
        const idMatch = data.text.match(/\(ID: (\d+)\)/);
        if (idMatch && idMatch[1]) {
            currentNoteId = idMatch[1];
            localStorage.setItem('currentNoteId', currentNoteId);
        }
        if ([ 'No parent note selected', 'No notes have been found', 'cleared successfully', 'Returned to main menu' ].some(m => data.text.includes(m))) {
            currentNoteId = null;
            localStorage.removeItem('currentNoteId');
        }
        if (![
            'Note created successfully',
            'Note updated successfully',
            'Note deleted successfully',
            '× ×•×¦×¨ ×‘×”×¦×œ×—×”',
            '×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×”',
            '× ××—×§ ×‘×”×¦×œ×—×”'
        ].some(sysMsg => data.text.includes(sysMsg))) {
            addMsg(data.text,'bot');
            updateModeFromMessage(data.text);
            if (useTTS.checked) speakText(data.text);
        }
    });
    
    SharedWebSocket.registerHandler('request_image_upload', (data) => {
        showUploadModal(data.data.noteId);
    });
    
    SharedWebSocket.registerHandler('trigger_image_upload', (data) => {
        currentNoteId = data.noteId;
        localStorage.setItem('currentNoteId', currentNoteId);
        showUploadModal(data.noteId);
    });
    
    SharedWebSocket.registerHandler('available_commands', (data) => {
        availableCommands = data.commands || [];
        commandsLoaded = true;
    });
    
    SharedWebSocket.registerHandler('found_notes', (data) => {
        if (!data.notes || data.notes.length === 0) {
            addMsg('No notes found', 'bot');
        }
    });
    
    SharedWebSocket.registerHandler('thinking', (data) => {
        showThinkingIndicator();
    });
    
    SharedWebSocket.registerHandler('thinking_done', (data) => {
        hideThinkingIndicator();
    });
}

/* ---------- Chat flow ---------- */
formEl.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = (inputEl.value || "").trim();
  if (!text) return;
  addMsg(text, "you");
  if (isCommand(text)) addToCommandHistory(text);
  inputEl.value = "";
  SharedWebSocket.send({ type: 'chat', text, lang: Settings.lang, autoConfirm: Settings.autoConfirm });
  scrollToBottom();
});

function isCommand(text) {
  return [ /^\/\w+/i, /^(create|find|show|help|edit|delete|mark|talk|stop|yes|no)\b/i ].some(p => p.test(text));
}

/* ---------- Speech-to-Text & Text-to-Speech ---------- */
let rec = null;
let isRecording = false;
micBtn.onclick = () => { isRecording ? stopRecording() : startRecording(); };

function startRecording() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) return addMsg("âŒ Speech Recognition not supported.", "sys");
  try {
    if (!rec) {
      rec = new SR();
      rec.continuous = true;
      rec.interimResults = true;
      rec.onstart = () => { isRecording = true; micBtn.textContent = "â–  Stop"; micBtn.classList.add("recording"); };
      rec.onresult = (e) => {
        let final = "", interim = "";
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const t = e.results[i][0].transcript;
          e.results[i].isFinal ? final += t : interim += t;
        }
        inputEl.value = final || interim;
      };
      rec.onerror = (e) => { addMsg("âŒ Speech error: " + e.error, "sys"); stopRecording(); };
      rec.onend = () => stopRecording();
    }
    rec.lang = (Settings.lang === "he") ? "he-IL" : "en-US";
    inputEl.value = "";
    rec.start();
  } catch (error) {
    addMsg("âŒ Failed to start speech recognition: " + error.message, "sys");
  }
}

function stopRecording() {
  if (rec && isRecording) rec.stop();
  isRecording = false;
  micBtn.textContent = "ğŸ¤ Speak";
  micBtn.classList.remove("recording");
}

async function speakText(text) {
  if (!useTTS.checked || !('speechSynthesis' in window)) return;
  try {
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = (Settings.lang === "he") ? "he-IL" : "en-US";
    window.speechSynthesis.speak(utterance);
  } catch (error) {
    console.error('Speech synthesis error:', error);
  }
}

/* ---------- URL Parameter Handling ---------- */
function handleUrlParameters() {
  const findbyid = new URLSearchParams(window.location.search).get('findbyid');
  if (findbyid) {
    addMsg(`Auto-finding note ID: ${findbyid}`, 'sys');
    SharedWebSocket.send({ type: 'chat', text: `/findbyid ${findbyid}`, lang: Settings.lang, autoConfirm: true });
  }
}

/* ---------- Thinking Indicator ---------- */
let thinkingInterval = null, thinkingDots = 0, thinkingMsg = null;
function showThinkingIndicator() {
  if (thinkingMsg) return;
  thinkingMsg = document.createElement('div');
  thinkingMsg.className = "msg bot";
  const mc = document.createElement("div");
  mc.className = "msg-content";
  mc.textContent = "Thinking";
  thinkingMsg.appendChild(mc);
  logEl.appendChild(thinkingMsg);
  thinkingInterval = setInterval(() => { mc.textContent = "Thinking" + ".".repeat((++thinkingDots) % 4); }, 500);
  scrollToBottom();
}
function hideThinkingIndicator() {
  if (thinkingInterval) clearInterval(thinkingInterval);
  thinkingInterval = null;
  if (thinkingMsg) thinkingMsg.remove();
  thinkingMsg = null;
}

/* ---------- Utilities ---------- */
function addMsg(text, who) {
  const div = document.createElement("div");
  div.className = "msg " + who;
  const mc = document.createElement("div");
  mc.className = "msg-content";
  mc.innerHTML = linkifyText(text);
  div.appendChild(mc);
  logEl.appendChild(div);
  saveMessageToHistory(text, who);
  if (who === "bot" && useTTS.checked) speakText(text);
  scrollToBottom();
}

function linkifyText(text) {
  const u = (s) => s.replace(/[&<]/g, c => c === '&' ? '&amp;' : '&lt;');
  return u(text).replace(/(https?:\[^\s]+)|(www\[^\s]+)/gi, (url) => {
    const href = url.startsWith('www.') ? 'https://' + url : url;
    return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
  });
}

function scrollToBottom(){ logEl.scrollTop = logEl.scrollHeight; }

function saveMessageToHistory(text, who) {
  let h = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  h.push({ text, who, timestamp: new Date().toISOString() });
  if (h.length > 100) h = h.slice(-100);
  localStorage.setItem('chatHistory', JSON.stringify(h));
}

function loadChatHistory() {
  const h = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  logEl.innerHTML = '';
  h.forEach(m => addMsg(m.text, m.who));
}

function clearChatHistory() {
  localStorage.removeItem('chatHistory');
  logEl.innerHTML = '';
}

function initializeSettings() {
  const key = localStorage.getItem('geminiApiKey');
  if (key) Settings.geminiApiKey = key;
  loadChatHistory();
}

function hideTipAfterDelay() {
  const tip = document.getElementById('tipSection');
  if (tip) setTimeout(() => { tip.style.display = 'none'; }, 10000);
}

/* ---------- Page Load ---------- */
initializeSettings();
loadCommandHistory();
initializeServiceWorker();
hideTipAfterDelay();

/* ---------- Upload Modal ---------- */
function showUploadModal(noteId) {
  currentNoteId = noteId;
  document.getElementById('uploadModal').classList.add('show');
  document.getElementById('fileInput').onchange = handleFileSelect;
}
function closeUploadModal() { document.getElementById('uploadModal').classList.remove('show'); }
function selectImages() { document.getElementById('fileInput').click(); }
function handleFileSelect(event) {
  if (!event.target.files) return;
  selectedFiles = Array.from(event.target.files).filter(f => f.type.startsWith('image/')).slice(0, 5);
  updatePreview();
  document.getElementById('uploadBtn').disabled = selectedFiles.length === 0;
}
function updatePreview() {
  const c = document.getElementById('previewContainer');
  const b = document.getElementById('uploadBtn');
  if (selectedFiles.length === 0) {
    c.innerHTML = '<p>No images selected</p>';
    b.disabled = true;
    return;
  }
  c.innerHTML = `<p>Selected ${selectedFiles.length} image(s)</p>`;
  b.disabled = false;
}
function uploadImages() {
  if (selectedFiles.length === 0 || !currentNoteId) return;
  addMsg(`ğŸ“¤ Uploading ${selectedFiles.length} image(s)...`, "sys");
  selectedFiles.forEach(file => {
    resizeAndCompressImage(file, (base64) => {
      SharedWebSocket.send({ type: 'image_upload', noteId: currentNoteId, imageName: file.name, imageData: base64 });
    });
  });
  closeUploadModal();
}
function resizeAndCompressImage(file, callback) {
  const i = new Image(), c = document.createElement('canvas'), x = c.getContext('2d');
  i.onload = () => {
    let w = i.width, h = i.height;
    if (w > 800) { h = h * 800 / w; w = 800; }
    if (h > 600) { w = w * 600 / h; h = 600; }
    c.width = w; c.height = h;
    x.drawImage(i, 0, 0, w, h);
    callback(c.toDataURL('image/jpeg', 0.8).split(',')[1]);
  };
  const r = new FileReader();
  r.onload = (e) => { i.src = e.target.result; };
  r.readAsDataURL(file);
}
</script>
</body>
</html>