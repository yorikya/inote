<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Note Secretary ‚Äì DroidScript Backend</title>
<style>
  body { margin:0; font-family: system-ui, Arial, sans-serif; background:#0b0d10; color:#e6e6e6; }
  .app { display:flex; flex-direction:column; height:100dvh; max-width:820px; margin:0 auto; }
  header { padding:12px 16px; border-bottom:1px solid #222; display:flex; gap:8px; align-items:center; }
  header h1 { font-size:16px; margin:0; font-weight:600; }
  header .spacer { flex:1; }
  select, button, input[type="text"] { background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:6px 10px; }
  #log { flex:1; overflow:auto; padding:16px; display:flex; flex-direction:column; gap:10px; }
  .msg { max-width:85%; padding:10px 12px; border-radius:14px; line-height:1.35; white-space:pre-wrap; display:flex; flex-direction:column; gap:4px; }
  .you { align-self:flex-end; background:#1f6feb; color:white; border-bottom-right-radius:4px; }
  .bot { align-self:flex-start; background:#15181c; border:1px solid #2a2f36; border-bottom-left-radius:4px; }
  .sys { align-self:center; font-size:12px; opacity:.8; }
  .msg-content { flex:1; }
  .msg-timestamp { font-size:10px; opacity:0.7; text-align:right; margin-top:2px; }
  .you .msg-timestamp { color:rgba(255,255,255,0.8); }
  .bot .msg-timestamp { color:#a0a0a0; }
  .sys .msg-timestamp { color:#a0a0a0; text-align:center; }
  form { display:flex; gap:8px; padding:12px 16px; border-top:1px solid #222; }
  textarea { flex:1; resize:none; height:70px; background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:10px; }
  button.primary { background:#1f6feb; color:white; border:none; border-radius:12px; padding:10px 14px; }
  #micBtn { background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:10px 14px; cursor:pointer; font-size:16px; transition: all 0.3s ease; }
  #micBtn.recording { background:#ff4444 !important; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; padding:8px 16px; }
  .warn { font-size:12px; opacity:.75; padding:0 16px; }
  
  /* Side Menu Styles */
  .side-menu { position:fixed; top:0; left:-300px; width:300px; height:100vh; background:#1a1d21; border-right:1px solid #333; z-index:1000; transition:left 0.3s ease; }
  .side-menu.open { left:0; }
  .side-menu-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .side-menu-content { padding:16px; }
  .side-menu h2 { margin:0 0 16px 0; font-size:18px; color:#e6e6e6; }
  .side-menu label { display:block; margin-bottom:8px; color:#e6e6e6; font-size:14px; }
  .side-menu input[type="text"], .side-menu input[type="password"] { width:100%; padding:8px; background:#2a2f36; color:#e6e6e6; border:1px solid #444; border-radius:6px; margin-bottom:16px; }
  .side-menu button { background:#1f6feb; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; margin-right:8px; }
  .side-menu button.secondary { background:#444; }
  .side-menu button.nav-button { width:100%; margin:0 0 8px 0; font-size:16px; padding:12px 16px; }
  .side-menu button.nav-button:disabled { opacity:0.5; cursor:not-allowed; }
  .side-menu button.nav-button.active { background:#2d5a87; border:2px solid #1f6feb; }
  .overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999; display:none; }
  .overlay.show { display:block; }
  
  /* Commands Popup Styles */
  .commands-popup { position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:400px; max-height:80vh; background:#1a1d21; border:1px solid #333; border-radius:12px; z-index:1001; display:none; overflow:hidden; }
  
  /* Upload Modal Styles */
  .upload-modal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1002; display:none; }
  .upload-modal.show { display:flex; align-items:center; justify-content:center; }
  .upload-content { background:#1a1d21; border:1px solid #333; border-radius:12px; width:90%; max-width:500px; max-height:80vh; overflow:hidden; }
  .upload-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .upload-header h3 { margin:0; color:#e6e6e6; }
  .upload-close { background:none; border:none; color:#a0a0a0; font-size:20px; cursor:pointer; }
  .upload-body { padding:20px; }
  .upload-area { border:2px dashed #444; border-radius:8px; padding:40px 20px; text-align:center; margin-bottom:20px; cursor:pointer; transition:border-color 0.3s; }
  .upload-area:hover { border-color:#1f6feb; }
  .upload-area.dragover { border-color:#1f6feb; background:#0f1419; }
  .upload-icon { font-size:48px; margin-bottom:16px; }
  .upload-text { color:#a0a0a0; margin-bottom:8px; }
  .upload-hint { font-size:12px; color:#666; }
  .file-input { display:none; }
  .preview-container { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:20px; }
  .preview-item { position:relative; width:80px; height:80px; border-radius:8px; overflow:hidden; }
  .preview-item img { width:100%; height:100%; object-fit:cover; }
  .preview-remove { position:absolute; top:4px; right:4px; background:#ff4444; color:white; border:none; border-radius:50%; width:20px; height:20px; font-size:12px; cursor:pointer; }
  .upload-buttons { display:flex; gap:10px; justify-content:flex-end; }
  .upload-btn { background:#1f6feb; color:white; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; }
  .upload-btn:disabled { background:#444; cursor:not-allowed; }
  .cancel-btn { background:#444; color:#e6e6e6; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; }
  .commands-popup.show { display:block; }
  .commands-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .commands-header h3 { margin:0; font-size:18px; color:#e6e6e6; }
  .commands-header button { background:none; border:none; color:#e6e6e6; font-size:20px; cursor:pointer; }
  .commands-content { padding:16px; max-height:60vh; overflow-y:auto; }
  .command-category { margin-bottom:20px; }
  .command-category h4 { margin:0 0 12px 0; font-size:14px; color:#e6e6e6; font-weight:600; }
  .command-btn { display:block; width:100%; padding:8px 12px; margin-bottom:6px; background:#2a2f36; color:#e6e6e6; border:1px solid #444; border-radius:6px; cursor:pointer; font-size:14px; text-align:left; transition:all 0.2s ease; }
  .command-btn:hover { background:#1f6feb; border-color:#1f6feb; }
  
  /* Connection Status Styles */
  .connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-right: 8px;
  }
  .connection-label {
    font-size: 12px;
    color: #a0a0a0;
    font-weight: 500;
  }
  .connection-led {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #ff4444;
    border: 2px solid #333;
    transition: all 0.3s ease;
  }
  .connection-led.connected {
    background: #44ff44;
    box-shadow: 0 0 8px rgba(68, 255, 68, 0.5);
  }
  .connection-led.disconnected {
    background: #ff4444;
    box-shadow: 0 0 8px rgba(255, 68, 68, 0.3);
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <button id="menuBtn">‚ò∞</button>
    <div class="spacer"></div>
    <div class="connection-status">
      <span class="connection-led" id="statusLed"></span>
      <span id="statusText">Connecting...</span>
    </div>
    <select id="lang">
      <option value="en-US">English</option>
      <option value="he-IL">◊¢◊ë◊®◊ô◊™</option>
    </select>
    <button id="clearBtn" class="secondary" title="Clear chat messages">üóëÔ∏è</button>
  </header>

  <p class="warn" id="tipSection">Tip: Try compact commands like <code>/createnote groceries</code> or <code>/findnote groceries</code>. For editing: <code>/findnote groceries</code> then <code>/editdescription</code>. To see all notes: <code>/showparents</code>. Speech works via the browser's Web Speech API. Gemini here is for **testing only**‚Äîyour key is exposed.</p>

  <div id="log"></div>

  <form id="chat">
    <textarea id="input" placeholder="Type a message‚Ä¶"></textarea>
    <button class="primary" type="submit">Send</button>
  </form>
  
  <div class="row" style="padding: 8px 16px; border-top: 1px solid #222;">
    <button id="helpBtn" class="secondary">Commands</button>
    <button id="micBtn" title="Speech to text">üé§ Speak</button>
    <label><input type="checkbox" id="useTTS"> üîä Read responses</label>
  </div>
</div>

<!-- Upload Modal -->
<div id="uploadModal" class="upload-modal">
  <div class="upload-content">
    <div class="upload-header">
      <h3>Upload Images</h3>
      <button class="upload-close" onclick="closeUploadModal()">&times;</button>
    </div>
            <div class="upload-body">
              <div class="upload-area" onclick="selectImages()">
                <div class="upload-icon">üì∑</div>
                <div class="upload-text">Click to select images</div>
                <div class="upload-hint">Supports JPG, PNG, GIF (max 5 images)</div>
              </div>
              
              
              
      <input type="file" id="fileInput" class="file-input" multiple accept="image/*" style="display: none;">
      <div id="previewContainer" class="preview-container"></div>
              <div class="upload-buttons">
                <button class="cancel-btn" onclick="closeUploadModal()">Cancel</button>
                <button class="upload-btn" id="uploadBtn" onclick="uploadImages()" disabled>Upload</button>
              </div>
    </div>
  </div>
</div>

<!-- Commands Popup -->
<div class="overlay" id="commandsOverlay"></div>
<div class="commands-popup" id="commandsPopup">
  <div class="commands-header">
    <h3>Quick Commands</h3>
    <button id="closeCommands">‚úï</button>
  </div>
  <div class="commands-content" id="commandsContent">
    <!-- Commands will be populated dynamically based on current mode -->
  </div>
</div>

<!-- Side Menu -->
<div class="overlay" id="overlay"></div>
<div class="side-menu" id="sideMenu">
  <div class="side-menu-header">
    <h2>Settings</h2>
    <button id="closeMenu">‚úï</button>
  </div>
  <div class="side-menu-content">
    <h3>Navigation</h3>
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:20px;">
      <button id="chatButton" class="nav-button active">üí¨ Chat</button>
      <button id="explorerButton" class="nav-button secondary">üìù Note Explorer</button>
    </div>
    
    <h3>Gemini API Configuration</h3>
    <label for="geminiApiKey">Gemini API Key:</label>
    <input type="password" id="geminiApiKey" placeholder="Enter your Gemini API key">
    <button id="saveApiKey">Save API Key</button>
    <button id="useDefaultKey" class="secondary">Use Default Key</button>
    
    <div style="margin-top:20px;">
      <h3>Current Status</h3>
      <div id="apiStatus">Using default API key</div>
    </div>
    
    <div style="margin-top:20px;">
        <h3>Workflow Settings</h3>
        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:16px;">
          <button id="toggleAutoConfirmBtn" class="nav-button" style="background:#2d5a87; color:white; border:none; padding:8px 12px; border-radius:4px; font-size:14px;">
            Auto Confirm: OFF
          </button>
          <small style="color:#666; font-size:12px;">Toggle auto confirmation for all actions</small>
        </div>
      <div style="font-size:12px; color:#a0a0a0; margin-bottom:16px;">
        When enabled, the system will automatically proceed with "Yes" for all confirmation prompts (note creation, deletion, marking as done, etc.)
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Chat History</h3>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <button id="clearChatHistory" class="secondary" style="background:#ff6b35;">üóëÔ∏è Clear Chat History</button>
        <small style="color:#a0a0a0; font-size:12px;">Clear all chat messages and history</small>
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Debug Tools</h3>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <button id="showNotes">Show Notes (Debug)</button>
        <button id="clearNotes" class="secondary" style="background:#ff4444;">üóëÔ∏è Clear All Notes (DANGER)</button>
      </div>
      <div id="notesDisplay" style="margin-top:10px; padding:10px; background:#2a2f36; border-radius:6px; max-height:200px; overflow-y:auto; font-family:monospace; font-size:12px; white-space:pre-wrap; display:none;"></div>
    </div>
  </div>
</div>

<script>
/* ---------- Settings ---------- */
const Settings = { 
  lang: "en",
  geminiApiKey: "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4", // Default API key
  autoConfirm: false
};

// Global variables
let currentNoteId = null;  // Store the current note ID for uploads
let selectedFiles = [];    // Store selected files for upload

// Global auto confirmation state
var GlobalAutoConfirm = {
  enabled: false,
  toggle: function() {
    this.enabled = !this.enabled;
    Settings.autoConfirm = this.enabled; // Update Settings object
    this.updateUI();
    this.saveToStorage();
    this.updateBackend();
    return this.enabled;
  },
  updateUI: function() {
    const btn = document.getElementById('toggleAutoConfirmBtn');
    if (btn) {
      btn.textContent = `Auto Confirm: ${this.enabled ? 'ON' : 'OFF'}`;
      btn.style.background = this.enabled ? '#28a745' : '#2d5a87';
    }
  },
  saveToStorage: function() {
    localStorage.setItem('globalAutoConfirm', this.enabled.toString());
  },
  loadFromStorage: function() {
    const saved = localStorage.getItem('globalAutoConfirm');
    this.enabled = saved === 'true';
    Settings.autoConfirm = this.enabled; // Update Settings object
    this.updateUI();
  },
  updateBackend: function() {
    // Send current state to backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'set_auto_confirm',
        enabled: this.enabled
      }));
      
      // Also update the autoConfirm setting for the next chat message
      Settings.autoConfirm = this.enabled;
    }
  }
};

/* ---------- UI wiring ---------- */
const logEl   = document.getElementById("log");
const inputEl = document.getElementById("input");
const formEl  = document.getElementById("chat");
const langSel = document.getElementById("lang");
const clearBtn= document.getElementById("clearBtn");
const micBtn  = document.getElementById("micBtn");
const useTTS  = document.getElementById("useTTS");

// Side menu elements
const menuBtn = document.getElementById("menuBtn");
const sideMenu = document.getElementById("sideMenu");
const overlay = document.getElementById("overlay");
const closeMenu = document.getElementById("closeMenu");
const geminiApiKey = document.getElementById("geminiApiKey");
const saveApiKey = document.getElementById("saveApiKey");
const useDefaultKey = document.getElementById("useDefaultKey");
const apiStatus = document.getElementById("apiStatus");
const showNotes = document.getElementById("showNotes");
const notesDisplay = document.getElementById("notesDisplay");
const clearNotes = document.getElementById("clearNotes");
const clearChatHistoryBtn = document.getElementById("clearChatHistory");
// Old checkbox removed - using toggle button system now
const chatButton = document.getElementById("chatButton");
const explorerButton = document.getElementById("explorerButton");

// Commands popup elements
const helpBtn = document.getElementById("helpBtn");
const commandsPopup = document.getElementById("commandsPopup");
const commandsOverlay = document.getElementById("commandsOverlay");
const closeCommands = document.getElementById("closeCommands");
const commandsContent = document.getElementById("commandsContent");

// Backend now handles all context detection

// Dynamic commands cache
let availableCommands = [];
let commandsLoaded = false;

// Command history management
let commandHistory = [];
const MAX_COMMAND_HISTORY = 10;

// Function to add command to history
function addToCommandHistory(command) {
  // Remove if already exists to avoid duplicates
  commandHistory = commandHistory.filter(cmd => cmd !== command);
  // Add to beginning
  commandHistory.unshift(command);
  // Keep only the latest 10
  if (commandHistory.length > MAX_COMMAND_HISTORY) {
    commandHistory = commandHistory.slice(0, MAX_COMMAND_HISTORY);
  }
  // Save to localStorage
  localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
}

// Function to load command history from localStorage
function loadCommandHistory() {
  const saved = localStorage.getItem('commandHistory');
  if (saved) {
    try {
      commandHistory = JSON.parse(saved);
    } catch (e) {
      commandHistory = [];
    }
  }
}

// Function to get command history
function getCommandHistory() {
  return commandHistory;
}

// Function to update connection status LED
function updateConnectionStatus(connected) {
  const statusLed = document.getElementById('statusLed');
  const statusText = document.getElementById('statusText');
  if (statusLed && statusText) {
    if (connected) {
      statusLed.className = 'connection-led connected';
      statusText.textContent = 'Connected';
      statusLed.title = 'Connected to server';
    } else {
      statusLed.className = 'connection-led disconnected';
      statusText.textContent = 'Connecting...';
      statusLed.title = 'Disconnected from server';
    }
  }
}

// Function to load available commands from backend
function loadAvailableCommands() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
      ws.send(JSON.stringify({type: 'get_commands'}));
    } catch (error) {
      console.log("Error requesting commands:", error);
    }
  }
}

// Function to generate dynamic commands HTML
function generateDynamicCommands() {
  if (availableCommands.length === 0) {
    return '<div class="command-category"><h4>‚ùå No commands available</h4></div>';
  }
  
  // Group commands by category
  const categories = {};
  availableCommands.forEach(cmd => {
    if (!categories[cmd.category]) {
      categories[cmd.category] = [];
    }
    categories[cmd.category].push(cmd);
  });
  
  let html = '';
  for (const category in categories) {
    html += `<div class="command-category">`;
    html += `<h4>${category}</h4>`;
    categories[category].forEach(cmd => {
      const commandText = cmd.requiresParam ? cmd.command + ' ' : cmd.command;
      let buttonText = cmd.command;
      
      // Generate command button
      
      // Add description to the button text
      if (cmd.description) {
        buttonText += ` <span style="opacity: 0.6; font-size: 0.85em; font-style: italic;">[${cmd.description}]</span>`;
      }
      
      // Add examples for commands that need parameters
      if (cmd.requiresParam && cmd.examples && cmd.examples.length > 0) {
        const example = cmd.examples[0];
        buttonText += ` <span style="opacity: 0.7; font-size: 0.9em;">(${example})</span>`;
      }
      
      const buttonHtml = `<button class="command-btn" data-command="${commandText}">${buttonText}</button>`;
      html += buttonHtml;
    });
    html += `</div>`;
  }
  
  return html;
}

// Function to update mode based on backend messages (simplified - backend handles context)
function updateModeFromMessage(message) {
  // Backend now handles all context detection, so we just need to trigger command refresh
  if (message.includes("What would you like to do?") || message.includes("◊û◊î ◊™◊®◊¶◊î ◊ú◊¢◊©◊ï◊™?") ||
      message.includes("To start editing") || message.includes("◊õ◊ì◊ô ◊ú◊î◊™◊ó◊ô◊ú ◊ú◊¢◊®◊ï◊ö") ||
      message.includes("Started AI conversation") || message.includes("◊î◊™◊ó◊ú◊™◊ô ◊©◊ô◊ó◊î ◊¢◊ù AI") ||
      message.includes("AI conversation cancelled") || message.includes("◊©◊ô◊ó◊î ◊¢◊ù AI ◊ë◊ï◊ò◊ú◊î") ||
      message.includes("Do you want to create") || message.includes("◊î◊ê◊ù ◊™◊®◊¶◊î ◊ú◊ô◊¶◊ï◊®") || 
      message.includes("Do you want to delete") || message.includes("◊î◊ê◊ù ◊™◊®◊¶◊î ◊ú◊û◊ó◊ï◊ß") ||
      message.includes("Do you want to mark") || message.includes("◊î◊ê◊ù ◊™◊®◊¶◊î ◊ú◊°◊û◊ü") ||
      message.includes("Which note would you like to select") || message.includes("◊ê◊ô◊ñ◊î ◊§◊™◊ß ◊™◊®◊¶◊î ◊ú◊ë◊ó◊ï◊®") ||
      message.includes("updated successfully") || message.includes("◊¢◊ï◊ì◊õ◊ü ◊ë◊î◊¶◊ú◊ó◊î") ||
      message.includes("created successfully") || message.includes("◊†◊ï◊¶◊® ◊ë◊î◊¶◊ú◊ó◊î") ||
      message.includes("deleted successfully") || message.includes("◊†◊û◊ó◊ß ◊ë◊î◊¶◊ú◊ó◊î") ||
      message.includes("cancelled") || message.includes("◊ë◊ï◊ò◊ú")) {
    
    // Request updated commands from backend
    loadAvailableCommands();
  }
}

langSel.onchange = () => {
  Settings.lang = langSel.value;
  document.documentElement.dir = (Settings.lang === "he") ? "rtl" : "ltr";
};
clearBtn.onclick = () => { 
  if (confirm("Are you sure you want to clear all chat messages? This action cannot be undone.")) {
    logEl.innerHTML = ""; 
    clearChatHistory();
    addMsg("üóëÔ∏è Chat messages cleared", "sys");
  }
};

/* ---------- Commands Popup Functionality ---------- */
// Function to populate commands based on backend context
function populateCommands() {
  commandsContent.innerHTML = '';
  
  // Add history section if there are commands in history
  const history = getCommandHistory();
  if (history.length > 0) {
    let historyHtml = `
      <div class="command-category">
        <h4>üïí Recent Commands</h4>
    `;
    for (let i = 0; i < Math.min(history.length, 5); i++) {
      const cmd = history[i];
      historyHtml += `<button class="command-btn" data-command="${cmd}">${cmd}</button>`;
    }
    historyHtml += `</div>`;
    commandsContent.innerHTML += historyHtml;
  }
  
  // Use backend commands exclusively
  if (commandsLoaded && availableCommands.length > 0) {
    const generatedHtml = generateDynamicCommands();
    commandsContent.innerHTML += generatedHtml;
  } else {
    // Fallback message if no commands available
    commandsContent.innerHTML += `
      <div class="command-category">
        <h4>‚ùå No commands available</h4>
        <p>Loading commands from backend...</p>
      </div>
    `;
  }
}

helpBtn.onclick = () => {
  populateCommands();
  commandsPopup.classList.add("show");
  commandsOverlay.classList.add("show");
};

closeCommands.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};

commandsOverlay.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};


// Handle command button clicks
document.addEventListener('click', (e) => {
  console.log("Click detected on:", e.target.tagName, "classes:", e.target.className);
  
  // Find the closest command button (handles clicks on child elements)
  const commandButton = e.target.closest('.command-btn');
  console.log("Closest command button:", commandButton);
  
  if (commandButton) {
    const command = commandButton.getAttribute('data-command');
    console.log("Command button clicked:", command);
    
    if (command) {
      // Add the command to the input field
      inputEl.value = command;
      console.log("Set input value to:", inputEl.value);
      
      // Add to command history
      addToCommandHistory(command);
      
      // Close the popup
      commandsPopup.classList.remove("show");
      commandsOverlay.classList.remove("show");
      
      // Focus on the input field for user to complete or send
      inputEl.focus();
      
      // Move cursor to end of text
      inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
      
      // Prevent event from bubbling
      e.preventDefault();
      e.stopPropagation();
    }
  }
});

/* ---------- Side Menu Functionality ---------- */
menuBtn.onclick = () => {
  sideMenu.classList.add("open");
  overlay.classList.add("show");
  loadStoredApiKey();
};

closeMenu.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

overlay.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

// Navigation functionality
function navigateToPage(page) {
  // Close the side menu
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
  
  // Update active button
  document.querySelectorAll('.nav-button').forEach(btn => btn.classList.remove('active'));
  
  switch(page) {
    case 'chat':
      // We're already on the chat page
      chatButton.classList.add('active');
      console.log("Already on Chat page");
      break;
    case 'explorer':
      // Navigate to explorer.html
      window.location.href = 'explorer.html';
      break;
  }
}

// Navigation button handlers
  chatButton.onclick = () => navigateToPage('chat');
  explorerButton.onclick = () => navigateToPage('explorer');
  
  // Auto confirm toggle button
  const toggleAutoConfirmBtn = document.getElementById('toggleAutoConfirmBtn');
  if (toggleAutoConfirmBtn) {
    toggleAutoConfirmBtn.onclick = () => {
      const newState = GlobalAutoConfirm.toggle();
      console.log('Auto confirmation toggled to:', newState);
    };
  }

// Old checkbox handler removed - using toggle button system now

// Load stored API key from localStorage
function loadStoredApiKey() {
  const storedKey = localStorage.getItem('geminiApiKey');
  if (storedKey) {
    geminiApiKey.value = storedKey;
    Settings.geminiApiKey = storedKey;
    apiStatus.textContent = "Using custom API key";
    apiStatus.style.color = "#4CAF50";
  } else {
    apiStatus.textContent = "Using default API key";
    apiStatus.style.color = "#FFA500";
  }
  
  // Old auto confirmation loading removed - using GlobalAutoConfirm system now
  
  // Initialize global auto confirm
  GlobalAutoConfirm.loadFromStorage();
  
  // Initialize Settings.autoConfirm with the current value
  Settings.autoConfirm = GlobalAutoConfirm.enabled;
}

// Old auto confirmation functions removed - using GlobalAutoConfirm system now

// Save API key
saveApiKey.onclick = () => {
  const key = geminiApiKey.value.trim();
  if (key) {
    localStorage.setItem('geminiApiKey', key);
    Settings.geminiApiKey = key;
    apiStatus.textContent = "Using custom API key";
    apiStatus.style.color = "#4CAF50";
    addMsg("‚úÖ API key saved successfully!", "sys");
    
    // Send API key to backend for daily summary
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({
          type: 'save_settings',
          geminiApiKey: key
        }));
      } catch (error) {
        console.log("Error sending API key to backend:", error);
      }
    }
  } else {
    addMsg("‚ùå Please enter a valid API key", "sys");
  }
};

// Use default API key
useDefaultKey.onclick = () => {
  localStorage.removeItem('geminiApiKey');
  Settings.geminiApiKey = "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4";
  geminiApiKey.value = "";
  apiStatus.textContent = "Using default API key";
  apiStatus.style.color = "#FFA500";
  addMsg("‚úÖ Switched to default API key", "sys");
  
  // Send default API key to backend for daily summary
  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
      ws.send(JSON.stringify({
        type: 'save_settings',
        geminiApiKey: "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4"
      }));
    } catch (error) {
      console.log("Error sending default API key to backend:", error);
    }
  }
};

// Show notes debug
showNotes.onclick = () => {
  if (notesDisplay.style.display === "none") {
    // Request notes from backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({type:'debug', action:'get_notes'}));
        showNotes.textContent = "Hide Notes";
        notesDisplay.style.display = "block";
      } catch (error) {
        addMsg("Error sending debug request: " + error.message, "sys");
      }
    } else {
      addMsg("Not connected to backend", "sys");
    }
  } else {
    // Hide notes
    showNotes.textContent = "Show Notes (Debug)";
    notesDisplay.style.display = "none";
  }
};

// Clear all notes
clearNotes.onclick = () => {
  const warningMessage = `‚ö†Ô∏è DANGER: Clear All Notes

This action will PERMANENTLY DELETE:
‚Ä¢ All notes and their descriptions
‚Ä¢ All sub-notes and their relationships  
‚Ä¢ All note history and metadata
‚Ä¢ All AI conversation history

üö® THIS ACTION CANNOT BE UNDONE! üö®

Are you absolutely sure you want to continue?`;

  if (confirm(warningMessage)) {
    // Double confirmation for extra safety
    const finalConfirm = confirm("FINAL WARNING: This will delete EVERYTHING!\n\nType 'DELETE' in the next prompt to confirm:");
    
    if (finalConfirm) {
      const userInput = prompt("Type 'DELETE' to permanently clear all notes:");
      
      if (userInput === 'DELETE') {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            ws.send(JSON.stringify({type:'debug', action:'clear_notes'}));
            addMsg("üóëÔ∏è Clearing all notes... This action cannot be undone!", "sys");
          } catch (error) {
            addMsg("Error sending clear request: " + error.message, "sys");
          }
        } else {
          addMsg("Not connected to backend", "sys");
        }
      } else {
        addMsg("‚ùå Clear operation cancelled - you must type 'DELETE' exactly", "sys");
      }
    } else {
      addMsg("‚ùå Clear operation cancelled", "sys");
    }
  } else {
    addMsg("‚ùå Clear operation cancelled", "sys");
  }
};

// Clear chat history
clearChatHistoryBtn.onclick = () => {
  if (confirm("Are you sure you want to clear all chat history? This action cannot be undone.")) {
    clearChatHistory();
    addMsg("üóëÔ∏è Chat history cleared", "sys");
  }
};

/* ---------- WebSocket connection to DroidScript backend ---------- */
let ws;
let reconnectInterval = 5000; // 5 seconds
let reconnectTimer = null;
let messageQueue = [];

function connect() {
  // Clear any existing reconnect timer
  if (reconnectTimer) {
    clearTimeout(reconnectTimer);
    reconnectTimer = null;
  }

  // If WebSocket is already connecting or open, do nothing
  if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
    return;
  }

  // Connect to DroidScript WebSocket server on localhost:30000
  // Auto-detect host: use 10.0.2.2 inside Android emulator, otherwise localhost
  const host = (function() {
    try {
      const h = window.location.hostname;
      // If page served from file:// or host is localhost, prefer localhost.
      if (h === 'localhost' || h === '' || h === '127.0.0.1') return '127.0.0.1';
      // For Android emulator webviews, the host to reach host machine is 10.0.2.2
      // Detect common emulator UA substring
      if (navigator.userAgent && navigator.userAgent.indexOf('Android') !== -1) return '10.0.2.2';
      return h || '127.0.0.1';
    } catch (e) {
      return '127.0.0.1';
    }
  })();
  const url = `ws://${host}:30000`;
  ws = new WebSocket(url);

  ws.onopen = () => {
    updateConnectionStatus(true);

    // Process any queued messages
    while (messageQueue.length > 0) {
      const message = messageQueue.shift();
      try {
        ws.send(JSON.stringify(message));
        addMsg(`‚úÖ Sent queued message: "${message.text.substring(0, 30)}..."`, "sys");
      } catch (error) {
        addMsg(`Error sending queued message: ${error.message}`, "sys");
        // If sending fails, put it back at the front of the queue
        messageQueue.unshift(message);
        // And close the connection to trigger a reconnect
        ws.close();
        break; // Exit the loop
      }
    }

    loadAvailableCommands();
    handleUrlParameters();

    const savedNoteId = localStorage.getItem('currentNoteId');
    if (savedNoteId) {
      ws.send(JSON.stringify({
        type: 'restore_context',
        noteId: savedNoteId
      }));
    }
  };

  ws.onclose = () => {
    updateConnectionStatus(false);
    if (!reconnectTimer) {
        reconnectTimer = setTimeout(connect, reconnectInterval);
    }
  };

  ws.onerror = e => {
    updateConnectionStatus(false);
    // onclose will be called next, which handles the reconnect logic.
    // No need to add a message here to avoid duplicates.
  };
  
  // In the ws.onmessage handler, add this case after the existing cases:
  
  ws.onmessage = ev=>{
      try{ 
        const msg=JSON.parse(ev.data); 
        console.log("DEBUG: Received WebSocket message:", msg.type, msg);
        
        if(msg.type==='reply') {
          // Try to extract noteId from the message text, e.g., "(ID: 123)"
          const idMatch = msg.text.match(/\(ID: (\d+)\)/);
          if (idMatch && idMatch[1]) {
            const noteId = idMatch[1];
            currentNoteId = noteId;
            localStorage.setItem('currentNoteId', currentNoteId);
            addMsg(`üìù Note context automatically set to ID: ${currentNoteId}`, 'sys');
          }

          // Check for messages that imply the context should be cleared.
          const clearContextMessages = [
            'No parent note selected',
            'No notes have been found',
            'cleared successfully',
            'Returned to main menu'
          ];

          if (clearContextMessages.some(m => msg.text.includes(m))) {
            currentNoteId = null;
            localStorage.removeItem('currentNoteId');
            addMsg('üìù Note context cleared.', 'sys');
          }

          // Filter out system messages that shouldn't be shown to user
          const systemMessages = [
            'Note created successfully',
            'Note updated successfully', 
            'Note deleted successfully',
            '◊†◊ï◊¶◊® ◊ë◊î◊¶◊ú◊ó◊î',
            '◊¢◊ï◊ì◊õ◊ü ◊ë◊î◊¶◊ú◊ó◊î',
            '◊†◊û◊ó◊ß ◊ë◊î◊¶◊ú◊ó◊î'
          ];
          
          // Check if this is a system message
          const isSystemMessage = systemMessages.some(sysMsg => msg.text.includes(sysMsg));
          
          // Only display if it's not a system message
          if (!isSystemMessage) {
            addMsg(msg.text,'bot');
            
            // Update mode based on backend message
            updateModeFromMessage(msg.text);
            
            // Speak bot responses if TTS is enabled
            if (useTTS.checked) {
              speakText(msg.text);
            }
          }
        }
        else if(msg.type==='request_image_upload') {
          console.log("DEBUG: Handling request_image_upload message");
          console.log("DEBUG: Note ID:", msg.data.noteId);
          console.log("DEBUG: Current image count:", msg.data.currentImageCount);
          
          // Show the upload modal for this note
          showUploadModal(msg.data.noteId);
          addMsg("üì∑ Please select an image to upload", "sys");
        }
        else if(msg.type==='trigger_image_upload') {
          console.log('DEBUG: Received trigger_image_upload with noteId:', msg.noteId);
          currentNoteId = msg.noteId;  // Store the noteId globally
          localStorage.setItem('currentNoteId', currentNoteId); // Save to local storage
          showUploadModal(msg.noteId);
        }
        else if(msg.type==='debug_notes') {
          notesDisplay.textContent = msg.notes;
          notesDisplay.style.display = "block";
        }
        else if(msg.type==='debug_cleared') {
          addMsg("All notes cleared successfully!", "sys");
          // Hide notes display if it's showing
          notesDisplay.style.display = "none";
          showNotes.textContent = "Show Notes (Debug)";
        }
        
        else if(msg.type==='available_commands') {
          // Handle dynamic commands from backend
          availableCommands = msg.commands || [];
          commandsLoaded = true;
          console.log("Loaded dynamic commands:", availableCommands);
        }
        else if(msg.type==='set_auto_confirm') {
          // Handle set_auto_confirm message from backend
          GlobalAutoConfirm.enabled = msg.enabled;
          Settings.autoConfirm = msg.enabled;
          GlobalAutoConfirm.updateUI();
        }
        else if(msg.type==='auto_confirm_status') {
          // Update UI when auto-confirmation status changes
          GlobalAutoConfirm.enabled = msg.enabled;
          Settings.autoConfirm = msg.enabled;
          GlobalAutoConfirm.updateUI();
        }
        else if(msg.type==='found_notes') {
          // Handle found_notes message with human-readable text
          if (msg.notes && msg.notes.length > 0) {
            // Notes found - let the backend handle the display
          } else {
            // No notes found - show human-readable message
            addMsg('No notes have been found', 'bot');
          }
        }
        else {
          console.log("DEBUG: Unhandled message type:", msg.type);
          addMsg(ev.data,'sys');
        }
      }
      catch(error){ 
        console.log("DEBUG: Error parsing WebSocket message:", error);
        addMsg(ev.data,'bot'); 
      }
    };
}


/* ---------- Chat flow ---------- */
formEl.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = (inputEl.value || "").trim();
  if (!text) return;

  addMsg(text, "you");

  // Add to command history if it looks like a command
  if (isCommand(text)) {
    addToCommandHistory(text);
  }

  inputEl.value = "";

  const message = { type: 'chat', text, lang: Settings.lang, autoConfirm: Settings.autoConfirm };

  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
      ws.send(JSON.stringify(message));
    } catch (error) {
      addMsg("Error sending message: " + error.message, "sys");
    }
  } else {
    addMsg("Connection is down. Queuing message and attempting to reconnect...", "sys");
    messageQueue.push(message);
    connect();
  }
  scrollToBottom();
});

// Function to check if text looks like a command
function isCommand(text) {
  const commandPatterns = [
    /^\/\w+/i, // Slash commands
    /^(create|find|show|help|edit|delete|mark|talk|stop|yes|no)\b/i,
    /^(◊¶◊ï◊®|◊û◊¶◊ê|◊î◊¶◊í|◊¢◊ñ◊®◊î|◊¢◊®◊ï◊ö|◊û◊ó◊ß|◊°◊û◊ü|◊ì◊ë◊®|◊¢◊¶◊ï◊®|◊õ◊ü|◊ú◊ê)\b/i
  ];
  return commandPatterns.some(pattern => pattern.test(text));
}

/* ---------- Speech-to-Text (Web Speech API) ---------- */
let rec = null;
let isRecording = false;

micBtn.onclick = () => {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
};

function startRecording() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { 
    addMsg("‚ùå Speech Recognition not supported in this browser.", "sys"); 
    return; 
  }
  
  try {
    if (!rec) {
      rec = new SR();
      rec.continuous = true;
      rec.interimResults = true;
      rec.maxAlternatives = 1;
      
      rec.onstart = () => {
        isRecording = true;
        micBtn.textContent = "‚ñ† Stop Recording";
        micBtn.classList.add("recording");
        addMsg("üé§ Listening... Speak now", "sys");
      };
      
      rec.onresult = (e) => {
        let finalTranscript = "";
        let interimTranscript = "";
        
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const transcript = e.results[i][0].transcript;
          if (e.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Normal mode - replace content
        if (finalTranscript) {
          inputEl.value = finalTranscript;
        } else if (interimTranscript) {
          inputEl.value = interimTranscript;
        }
      };
      
      rec.onerror = (e) => {
        addMsg("‚ùå Speech recognition error: " + e.error, "sys");
        stopRecording();
      };
      
      rec.onend = () => {
        stopRecording();
      };
    }
    
    // Set language
    rec.lang = (Settings.lang === "he") ? "he-IL" : "en-US";
    
    // Clear input field
    inputEl.value = "";
    
    // Start recognition
    rec.start();
    
  } catch (error) {
    addMsg("‚ùå Failed to start speech recognition: " + error.message, "sys");
  }
}

function stopRecording() {
  if (rec && isRecording) {
    rec.stop();
  }
  isRecording = false;
  micBtn.textContent = "üé§ Speak";
  micBtn.classList.remove("recording");
  
  if (inputEl.value.trim()) {
    addMsg("‚úÖ Ready to send: " + inputEl.value, "sys");
  }
}


/* ---------- Text-to-Speech ---------- */
async function speakText(text) {
  if (!useTTS.checked) return;
  
  const lang = (Settings.lang === "he") ? "he" : "en";
  const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&client=tw-ob&q=${encodeURIComponent(text)}`;
  
  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (response.ok) {
      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      audio.play();
      audio.onended = () => URL.revokeObjectURL(audioUrl);
    } else {
      addMsg("‚ùå Cannot read message: No internet connection", "sys");
    }
  } catch (error) {
    addMsg("‚ùå Cannot read message: No internet connection", "sys");
  }
}

/* ---------- URL Parameter Handling ---------- */
function handleUrlParameters() {
  const urlParams = new URLSearchParams(window.location.search);
  const findbyid = urlParams.get('findbyid');
  
  if (findbyid) {
    // Auto-execute /findbyid command
    console.log('Auto-executing /findbyid command for note:', findbyid);
    addMsg(`Auto-finding note ID: ${findbyid}`, 'sys');
    
    // Send the command to the backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'chat',
        text: `/findbyid ${findbyid}`,
        lang: Settings.lang,
        autoConfirm: Settings.autoConfirm
      }));
    } else {
      // If WebSocket is not ready, wait a bit and try again
      setTimeout(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'chat',
            text: `/findbyid ${findbyid}`,
            lang: Settings.lang,
            autoConfirm: Settings.autoConfirm
          }));
        }
      }, 1000);
    }
  }
}

// Reconnect when returning to the tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    // User returned to the tab, check if we need to reconnect
    if (!ws || ws.readyState === WebSocket.CLOSED) {
      addMsg("üëã Welcome back! Reconnecting...", "sys");
      connect();
    }
  }
});

/* ---------- Utilities ---------- */
function addMsg(text, who) {
  const div = document.createElement("div");
  div.className = "msg " + (who === "you" ? "you" : who === "bot" ? "bot" : "sys");
  
  // Create message content with timestamp
  const messageContent = document.createElement("div");
  messageContent.className = "msg-content";
  messageContent.textContent = text;
  
  // Create timestamp
  const timestamp = document.createElement("div");
  timestamp.className = "msg-timestamp";
  timestamp.textContent = formatTimestamp(new Date());
  
  // Add content and timestamp to message
  div.appendChild(messageContent);
  div.appendChild(timestamp);
  
  logEl.appendChild(div);
  
  // Save message to chat history
  saveMessageToHistory(text, who);
  
  // Speak bot responses if TTS is enabled
  if (who === "bot" && useTTS.checked) {
    speakText(text);
  }
  
  scrollToBottom();
}
function scrollToBottom(){ logEl.scrollTop = logEl.scrollHeight; }

// Format timestamp for display (like WhatsApp)
function formatTimestamp(date) {
  const now = new Date();
  const messageDate = new Date(date);
  
  // Check if it's today
  if (messageDate.toDateString() === now.toDateString()) {
    return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Check if it's yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (messageDate.toDateString() === yesterday.toDateString()) {
    return "Yesterday " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Check if it's this week
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  if (messageDate > weekAgo) {
    return messageDate.toLocaleDateString([], { weekday: 'short' }) + " " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Older messages show date and time
  return messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + " " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

// -------- Chat History Management --------
function saveMessageToHistory(text, who) {
  const message = {
    text: text,
    who: who,
    timestamp: new Date().toISOString()
  };
  
  // Get existing chat history
  let chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  
  // Add new message
  chatHistory.push(message);
  
  // Keep only last 100 messages to prevent localStorage from getting too large
  if (chatHistory.length > 100) {
    chatHistory = chatHistory.slice(-100);
  }
  
  // Save to localStorage
  localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
}

function loadChatHistory() {
  const chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  
  // Clear current chat log
  logEl.innerHTML = '';
  
  // Restore all messages with timestamps
  chatHistory.forEach(message => {
    const div = document.createElement("div");
    div.className = "msg " + (message.who === "you" ? "you" : message.who === "bot" ? "bot" : "sys");
    
    // Create message content
    const messageContent = document.createElement("div");
    messageContent.className = "msg-content";
    messageContent.textContent = message.text;
    
    // Create timestamp from stored timestamp
    const timestamp = document.createElement("div");
    timestamp.className = "msg-timestamp";
    timestamp.textContent = formatTimestamp(new Date(message.timestamp));
    
    // Add content and timestamp to message
    div.appendChild(messageContent);
    div.appendChild(timestamp);
    
    logEl.appendChild(div);
  });
  
  // Scroll to bottom
  scrollToBottom();
}

function clearChatHistory() {
  localStorage.removeItem('chatHistory');
  logEl.innerHTML = '';
}

// Initialize settings on page load
function initializeSettings() {
  // Load stored API key
  const storedKey = localStorage.getItem('geminiApiKey');
  if (storedKey) {
    Settings.geminiApiKey = storedKey;
  }
  
  // Load chat history
  loadChatHistory();
}

// Hide tip section after 10 seconds
function hideTipAfterDelay() {
  const tipSection = document.getElementById('tipSection');
  if (tipSection) {
    setTimeout(() => {
      tipSection.style.display = 'none';
    }, 10000); // 10 seconds
  }
}

// Connect to DroidScript backend on page load
initializeSettings();
loadCommandHistory();
// Initialize connection LED as disconnected
updateConnectionStatus(false);
connect();
hideTipAfterDelay();

/* ---------- Upload Modal Functionality ---------- */
// DEPRECATED: HTML upload modal no longer used
// All image uploads now handled natively in DroidScript
function showUploadModal(noteId) {
  currentNoteId = noteId;
  document.getElementById('uploadModal').classList.add('show');
  
  // Setup file input handler
  const fileInput = document.getElementById('fileInput');
  fileInput.onchange = handleFileSelect;
  
  // Also add event listener for better compatibility
  fileInput.addEventListener('change', handleFileSelect);
  
  // Setup drag and drop
  const uploadArea = document.querySelector('.upload-area');
  uploadArea.ondragover = (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  };
  uploadArea.ondragleave = () => {
    uploadArea.classList.remove('dragover');
  };
  uploadArea.ondrop = (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    handleFileSelect({ target: { files: e.dataTransfer.files } });
  };
}

// Select images function - WebView-compatible approach
function selectImages() {
  console.log("DEBUG: selectImages called");
  console.log("DEBUG: Current selectedFiles length:", selectedFiles.length);
  console.log("DEBUG: User agent:", navigator.userAgent);
  
  // Check if we're in a WebView environment
  const isWebView = navigator.userAgent.includes('wv') || window.AndroidInterface;
  console.log("DEBUG: Detected WebView environment:", isWebView);
  
  // Try to trigger the hidden file input directly
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    console.log("DEBUG: Found file input, triggering HTML file picker");
    console.log("DEBUG: File input current value:", fileInput.value);
    
    // Clear any previous selection
    fileInput.value = '';
    console.log("DEBUG: Cleared file input value");
    
    // Multiple event listeners for WebView compatibility
    const handleFileChange = function(event) {
      console.log("DEBUG: File input change event triggered in selectImages");
      console.log("DEBUG: Event files length:", event.target.files ? event.target.files.length : 'no files');
      if (event.target.files && event.target.files.length > 0) {
        handleFileSelect(event);
      }
      // Remove the event listener after use
      fileInput.removeEventListener('change', handleFileChange);
      fileInput.removeEventListener('input', handleFileChange);
    };
    
    // Add multiple event listeners for better WebView compatibility
    fileInput.addEventListener('change', handleFileChange);
    fileInput.addEventListener('input', handleFileChange);  // Alternative event for WebView
    
    // Also try focus/blur events as some WebViews use these
    const handleFocusEvents = function() {
      console.log("DEBUG: File input focus/blur event - checking for files");
      setTimeout(() => {
        if (fileInput.files && fileInput.files.length > 0) {
          console.log("DEBUG: Files detected via focus/blur check");
          handleFileSelect({ target: fileInput });
        }
      }, 100);
    };
    
    fileInput.addEventListener('focus', handleFocusEvents);
    fileInput.addEventListener('blur', handleFocusEvents);
    
    console.log("DEBUG: Added multiple event listeners, about to click file input");
    fileInput.click();
    console.log("DEBUG: File input clicked");
    
    // WebView-specific polling mechanism
    let pollCount = 0;
    const maxPolls = 30; // Poll for 3 seconds
    const pollInterval = setInterval(() => {
      pollCount++;
      console.log("DEBUG: Polling for files, attempt:", pollCount);
      
      if (fileInput.files && fileInput.files.length > 0) {
        console.log("DEBUG: Files detected via polling:", fileInput.files.length);
        clearInterval(pollInterval);
        handleFileSelect({ target: fileInput });
        return;
      }
      
      if (pollCount >= maxPolls) {
        console.log("DEBUG: Polling timeout reached, no files detected");
        clearInterval(pollInterval);
        // Clean up event listeners
        fileInput.removeEventListener('change', handleFileChange);
        fileInput.removeEventListener('input', handleFileChange);
        fileInput.removeEventListener('focus', handleFocusEvents);
        fileInput.removeEventListener('blur', handleFocusEvents);
        
        if (selectedFiles.length === 0) {
          console.log("DEBUG: No files selected after polling, showing fallback options");
          showWebViewFilePickerFallback();
        }
      }
    }, 100);
    
  } else {
    console.log("DEBUG: File input not found, using native picker");
    selectImagesNative();
  }
}



// Close upload modal
function closeUploadModal() {
  document.getElementById('uploadModal').classList.remove('show');
  currentNoteId = null;
  selectedFiles = [];
}

// Handle file selection
function handleFileSelect(event) {
  console.log("DEBUG: handleFileSelect called");
  console.log("DEBUG: Event:", event);
  console.log("DEBUG: Event target:", event.target);
  console.log("DEBUG: Event target files:", event.target.files);
  console.log("DEBUG: Files length:", event.target.files ? event.target.files.length : 'no files');
  
  if (!event.target.files || event.target.files.length === 0) {
    console.log("DEBUG: No files in event, returning early");
    return;
  }
  
  const files = Array.from(event.target.files);
  console.log("DEBUG: Files array:", files);
  console.log("DEBUG: Files array length:", files.length);
  
  // Filter for images only and limit to 5
  const imageFiles = files.filter(file => {
    console.log("DEBUG: Checking file:", file.name, "type:", file.type);
    return file.type.startsWith('image/');
  });
  console.log("DEBUG: Filtered to", imageFiles.length, "image files");
  
  if (imageFiles.length > 5) {
    addMsg("‚ö†Ô∏è Maximum 5 images allowed", "sys");
    imageFiles.splice(5);
  }
  
  selectedFiles = imageFiles;
  console.log("DEBUG: selectedFiles updated to", selectedFiles.length, "files");
  console.log("DEBUG: selectedFiles content:", selectedFiles);
  
  updatePreview();
  
  const uploadBtn = document.getElementById('uploadBtn');
  if (uploadBtn) {
    uploadBtn.disabled = selectedFiles.length === 0;
    console.log("DEBUG: Upload button disabled:", uploadBtn.disabled);
  }
  
  if (selectedFiles.length > 0) {
    console.log("DEBUG: Adding success message for", selectedFiles.length, "files");
    addMsg(`üì∑ ${selectedFiles.length} image(s) selected`, "sys");
  } else {
    console.log("DEBUG: No image files selected");
    addMsg("üì∑ No valid image files selected", "sys");
  }
}

// Update preview container
function updatePreview() {
  const container = document.getElementById('previewContainer');
  const uploadBtn = document.getElementById('uploadBtn');
  
  if (selectedFiles.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No images selected</p>';
    uploadBtn.disabled = true;
    return;
  }
  
  // Simple display: just show count and file names
  const fileCount = selectedFiles.length;
  const fileNames = selectedFiles.map(file => file.name).join(', ');
  
  container.innerHTML = `
    <div style="padding: 20px; text-align: center; background: #f5f5f5; border-radius: 8px; margin: 10px 0;">
      <h3 style="margin: 0 0 10px 0; color: #333;">üì∏ Selected ${fileCount} picture${fileCount > 1 ? 's' : ''}</h3>
      <p style="color: #666; font-size: 14px; margin: 10px 0; word-break: break-all;">${fileNames}</p>
      <button onclick="clearSelectedFiles()" style="background: #ff4444; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">Clear Selection</button>
    </div>
  `;
  
  uploadBtn.disabled = false;
}

// Remove file from selection
function removeFile(index) {
  selectedFiles.splice(index, 1);
  updatePreview();
  document.getElementById('uploadBtn').disabled = selectedFiles.length === 0;
}

// Clear all selected files
function clearSelectedFiles() {
  selectedFiles = [];
  updatePreview();
  addMsg("üì∑ File selection cleared", "sys");
}

// Create mock file selection for testing/fallback
function createMockFileSelection() {
  console.log("DEBUG: Creating mock file selection");
  
  // Create a more realistic mock file object
  const mockFile = {
    name: 'mock_image_' + Date.now() + '.jpg',
    type: 'image/jpeg',
    size: 1024 * 50, // 50KB
    lastModified: Date.now(),
    lastModifiedDate: new Date(),
    webkitRelativePath: '',
    // Add methods that might be called
    stream: function() { return new ReadableStream(); },
    text: function() { return Promise.resolve('mock file content'); },
    arrayBuffer: function() { return Promise.resolve(new ArrayBuffer(1024)); },
    slice: function(start, end, contentType) { 
      return new Blob(['mock'], { type: contentType || this.type }); 
    },
    // Mark as mock for special handling
    isMockFile: true,
    constructor: { name: 'File' }
  };
  
  console.log("DEBUG: Created mock file:", mockFile.name);
  
  // Simulate file selection
  selectedFiles = [mockFile];
  console.log("DEBUG: Mock file added to selectedFiles");
  
  // Update the preview and enable upload button
  updatePreview();
  
  const uploadBtn = document.getElementById('uploadBtn');
  if (uploadBtn) {
    uploadBtn.disabled = false;
    console.log("DEBUG: Upload button enabled for mock file");
  }
  
  // Show success message
  addMsg("üß™ Mock file selected: " + mockFile.name, "sys");
  addMsg("üì∑ 1 image selected (mock file for testing)", "sys");
}

function uploadImages() {
  if (selectedFiles.length === 0) {
    addMsg("‚ùå No files selected.", "sys");
    return;
  }
  if (!currentNoteId) {
    addMsg("‚ùå No note selected for upload.", "sys");
    return;
  }

  addMsg(`üì§ Uploading ${selectedFiles.length} image(s)...`, "sys");

  let uploadedCount = 0;
  const totalFiles = selectedFiles.length;

  selectedFiles.forEach(file => {
    resizeAndCompressImage(file, (base64Data) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        const message = {
          type: 'image_upload',
          noteId: currentNoteId,
          imageName: file.name,
          imageData: base64Data
        };
        addMsg('DEBUG: Sending image upload message: ' + JSON.stringify(message).substring(0, 100) + '...', 'sys');
        ws.send(JSON.stringify(message));

        uploadedCount++;
        if (uploadedCount === totalFiles) {
          closeUploadModal();
        }
      }
    });
  });
}

// Image resizing and compression function
function resizeAndCompressImage(file, callback) {
  console.log("DEBUG: Resizing image:", file.name, "Size:", file.size, "bytes");
  
  // Check if this is a mock file
  if (file.name && (file.name.startsWith('debug_image') || file.name.startsWith('test_image'))) {
    console.log("DEBUG: Mock file detected, using mock base64 data");
    // Use a small mock base64 image (1x1 transparent PNG)
    const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    callback(mockBase64);
    return;
  }
  
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  
  img.onload = function() {
    console.log("DEBUG: Original image dimensions:", img.width, "x", img.height);
    
    // Calculate new dimensions (max 800px width, maintain aspect ratio)
    const maxWidth = 800;
    const maxHeight = 600;
    let { width, height } = img;
    
    if (width > maxWidth) {
      height = (height * maxWidth) / width;
      width = maxWidth;
    }
    if (height > maxHeight) {
      width = (width * maxHeight) / height;
      height = maxHeight;
    }
    
    console.log("DEBUG: Resized dimensions:", width, "x", height);
    
    // Set canvas size
    canvas.width = width;
    canvas.height = height;
    
    // Draw resized image
    ctx.drawImage(img, 0, 0, width, height);
    
    // Convert to base64 with compression (0.8 quality)
    const resizedBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
    
    console.log("DEBUG: Resized image size:", resizedBase64.length, "characters");
    console.log("DEBUG: Compression ratio:", Math.round((1 - resizedBase64.length / (file.size * 1.33)) * 100) + "%");
    
    callback(resizedBase64);
  };
  
  img.onerror = function() {
    console.log("DEBUG: Error loading image, using original file");
    // Fallback to original file
    const reader = new FileReader();
    reader.onload = function(e) {
      const base64Data = e.target.result.split(',')[1];
      callback(base64Data);
    };
    reader.onerror = function(e) {
      console.log("DEBUG: FileReader error, using mock data");
      // Final fallback to mock data
      const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
      callback(mockBase64);
    };
    reader.readAsDataURL(file);
  };
  
  // Load the image
  const reader = new FileReader();
  reader.onload = function(e) {
    img.src = e.target.result;
  };
  reader.onerror = function(e) {
    console.log("DEBUG: FileReader error loading file, using mock data");
    const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    callback(mockBase64);
  };
  reader.readAsDataURL(file);
}


</script>
</body>
</html>
</html>
