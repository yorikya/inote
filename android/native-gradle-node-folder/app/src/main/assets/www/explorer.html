<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Note Explorer ‚Äì Note Secretary</title>
<link rel="stylesheet" href="common.css">
<link rel="stylesheet" href="explorer.css">
<style>
  /* Override any conflicting styles and ensure side menu works properly */
  body {
    margin: 0;
    font-family: system-ui, Arial, sans-serif;
    background: #0b0d10;
    color: #e6e6e6;
    overflow-x: hidden;
  }

  /* Side Menu - Fixed positioning on LEFT side */
  .side-menu {
    position: fixed !important;
    top: 0 !important;
    left: -300px !important;  /* Changed from right to left */
    width: 300px !important;
    height: 100vh !important;
    background: #1e1e1e !important;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5) !important;  /* Changed shadow direction */
    transition: left 0.3s ease !important;  /* Changed from right to left */
    z-index: 1001 !important;
    overflow-y: auto !important;
  }

  .side-menu.open {
    left: 0 !important;  /* Changed from right to left */
  }

  .side-menu-header {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    padding: 20px !important;
    border-bottom: 1px solid #333 !important;
  }

  .side-menu-header h2 {
    margin: 0 !important;
    font-size: 20px !important;
    color: #fff !important;
  }

  .side-menu-header button {
    background: none !important;
    border: none !important;
    color: #fff !important;
    font-size: 24px !important;
    cursor: pointer !important;
    padding: 0 !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  .side-menu-content {
    padding: 20px !important;
  }

  .side-menu-content h3 {
    margin: 0 0 10px 0 !important;
    font-size: 16px !important;
    color: #fff !important;
  }

  /* Overlay */
  .overlay {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0, 0, 0, 0.5) !important;
    z-index: 1000 !important;
    display: none !important;
  }

  .overlay.show {
    display: block !important;
  }

  /* Navigation buttons */
  .nav-button {
    width: 100% !important;
    padding: 12px 16px !important;
    margin-bottom: 8px !important;
    background: #2a2f36 !important;
    color: #e6e6e6 !important;
    border: 1px solid #444 !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    font-size: 16px !important;
    text-align: left !important;
    transition: all 0.2s ease !important;
  }

  .nav-button:hover {
    background: #1f6feb !important;
    border-color: #1f6feb !important;
  }

  .nav-button.active {
    background: #1f6feb !important;
    border-color: #1f6feb !important;
  }

  .nav-button.secondary {
    background: #2a2f36 !important;
  }
</style>
</head>
<body>
<div class="app">
  <!-- Header -->
  <header>
    <button id="menuBtn">‚ò∞</button>
    <h1>üìù Note Explorer</h1>
    <div class="spacer"></div>
    <button id="refreshBtn">üîÑ Refresh</button>
  </header>
  
  <!-- Search Bar -->
  <div class="search-container">
    <input type="text" id="searchInput" class="search-bar" placeholder="Search notes...">
  </div>
  
  <!-- Notes Container -->
  <div class="notes-container">
    <div id="loadingState" class="loading" style="display:none;">Loading notes...</div>
    <div id="emptyState" class="empty-state" style="display:none;">
      <h3>No notes found</h3>
      <p>Create your first note using the Chat interface</p>
    </div>
    <div id="notesGrid" class="notes-grid"></div>
  </div>
  
  <!-- Edit Note Modal -->
  <div id="editModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">‚úèÔ∏è Edit Note</h3>
        <button class="modal-close" onclick="closeEditModal()">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Note ID (read-only) -->
        <div>
          <label>Note ID</label>
          <input type="text" id="editNoteId" readonly disabled>
        </div>
        
        <!-- Title -->
        <div>
          <label>Title *</label>
          <input type="text" id="editNoteTitle" placeholder="Enter note title" required>
        </div>
        
        <!-- Description -->
        <div>
          <label>Description</label>
          <textarea id="editNoteDescription" rows="6" placeholder="Enter note description"></textarea>
        </div>
        
        <!-- Status -->
        <div>
          <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
            <input type="checkbox" id="editNoteDone">
            <span>Mark as completed</span>
          </label>
        </div>
        
        <!-- Action Buttons -->
        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
          <button onclick="closeEditModal()">‚ùå Cancel</button>
          <button onclick="saveNoteChanges()">üíæ Save Changes</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Side Menu -->
<div class="overlay" id="overlay"></div>
<div class="side-menu" id="sideMenu">
  <div class="side-menu-header">
    <h2>Menu</h2>
    <button id="closeMenu">‚úï</button>
  </div>
  <div class="side-menu-content">
    <h3>Navigation</h3>
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:20px;">
      <button id="chatButton" class="nav-button">üí¨ Chat</button>
      <button id="explorerButton" class="nav-button active">üìù Note Explorer</button>
    </div>
    
    <h3>Filter Options</h3>
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:20px;">
      <button id="showAllBtn" class="nav-button">üìã All Notes</button>
      <button id="showCompletedBtn" class="nav-button secondary">‚úÖ Completed</button>
      <button id="showPendingBtn" class="nav-button secondary">‚è≥ Pending</button>
    </div>
  </div>
</div>

<script>
// Elements
const menuBtn = document.getElementById("menuBtn");
const sideMenu = document.getElementById("sideMenu");
const overlay = document.getElementById("overlay");
const closeMenu = document.getElementById("closeMenu");
const searchInput = document.getElementById("searchInput");
const refreshBtn = document.getElementById("refreshBtn");
const notesGrid = document.getElementById("notesGrid");
const loadingState = document.getElementById("loadingState");
const emptyState = document.getElementById("emptyState");

// Navigation elements
const chatButton = document.getElementById("chatButton");
const explorerButton = document.getElementById("explorerButton");

// Filter elements
const showAllBtn = document.getElementById("showAllBtn");
const showCompletedBtn = document.getElementById("showCompletedBtn");
const showPendingBtn = document.getElementById("showPendingBtn");

// Edit modal elements
const editModal = document.getElementById("editModal");
const editNoteId = document.getElementById("editNoteId");
const editNoteTitle = document.getElementById("editNoteTitle");
const editNoteDescription = document.getElementById("editNoteDescription");
const editNoteDone = document.getElementById("editNoteDone");

// State
let allNotes = [];
let filteredNotes = [];
let currentFilter = 'all';
let noteImageStates = {}; // Track current image index for each note
let imageRotationIntervals = {}; // Track auto-rotation intervals
let currentEditingNoteId = null;

// WebSocket connection
let ws = null;

// ========== IMAGE ROTATION FUNCTIONS (GLOBAL SCOPE) ==========

// Initialize image state for a note
function initializeNoteImageState(noteId, imageCount) {
  console.log(`[ImageRotation] Initializing state for note ${noteId}, imageCount: ${imageCount}`);
  if (!noteImageStates[noteId]) {
    noteImageStates[noteId] = {
      currentIndex: 0,
      totalImages: imageCount
    };
    console.log(`[ImageRotation] Created new state for note ${noteId}:`, noteImageStates[noteId]);
  } else {
    console.log(`[ImageRotation] State already exists for note ${noteId}:`, noteImageStates[noteId]);
  }
}

// Manual image rotation (via arrow buttons) - MUST BE GLOBAL
window.rotateImage = function(noteId, direction) {
  console.log(`[ImageRotation] rotateImage called - noteId: ${noteId}, direction: ${direction}`);
  
  const note = allNotes.find(n => n.id === noteId);
  if (!note) {
    console.error(`[ImageRotation] Note not found: ${noteId}`);
    return;
  }
  
  if (!note.images || note.images.length <= 1) {
    console.log(`[ImageRotation] Note ${noteId} has ${note.images ? note.images.length : 0} images, rotation not needed`);
    return;
  }
  
  console.log(`[ImageRotation] Note ${noteId} has ${note.images.length} images`);
  
  // Initialize state if needed
  initializeNoteImageState(noteId, note.images.length);
  
  // Update index
  const state = noteImageStates[noteId];
  const oldIndex = state.currentIndex;
  state.currentIndex = (state.currentIndex + direction + state.totalImages) % state.totalImages;
  
  console.log(`[ImageRotation] Index changed from ${oldIndex} to ${state.currentIndex}`);
  console.log(`[ImageRotation] New image path: ${note.images[state.currentIndex]}`);
  
  // Update the image display
  updateNoteImage(noteId, note.images[state.currentIndex], state.currentIndex);
};

// Auto-rotate images for a note
function startImageRotation(noteId) {
  console.log(`[ImageRotation] Starting auto-rotation for note ${noteId}`);
  
  const note = allNotes.find(n => n.id === noteId);
  if (!note) {
    console.error(`[ImageRotation] Cannot start rotation - note not found: ${noteId}`);
    return;
  }
  
  if (!note.images || note.images.length <= 1) {
    console.log(`[ImageRotation] Note ${noteId} has ${note.images ? note.images.length : 0} images, auto-rotation not needed`);
    return;
  }
  
  console.log(`[ImageRotation] Note ${noteId} has ${note.images.length} images, starting auto-rotation`);
  
  // Clear any existing interval
  if (imageRotationIntervals[noteId]) {
    console.log(`[ImageRotation] Clearing existing interval for note ${noteId}`);
    clearInterval(imageRotationIntervals[noteId]);
  }
  
  // Initialize state
  initializeNoteImageState(noteId, note.images.length);
  
  // Start rotation (every 3 seconds)
  imageRotationIntervals[noteId] = setInterval(() => {
    console.log(`[ImageRotation] Auto-rotating note ${noteId}`);
    window.rotateImage(noteId, 1);
  }, 3000);
  
  console.log(`[ImageRotation] Auto-rotation interval set for note ${noteId}, interval ID:`, imageRotationIntervals[noteId]);
}

// Stop image rotation for a note
function stopImageRotation(noteId) {
  console.log(`[ImageRotation] Stopping rotation for note ${noteId}`);
  if (imageRotationIntervals[noteId]) {
    clearInterval(imageRotationIntervals[noteId]);
    delete imageRotationIntervals[noteId];
    console.log(`[ImageRotation] Rotation stopped for note ${noteId}`);
  } else {
    console.log(`[ImageRotation] No active rotation found for note ${noteId}`);
  }
}

// Update note image display
function updateNoteImage(noteId, imagePath, currentIndex) {
  console.log(`[ImageRotation] Updating image for note ${noteId}, index: ${currentIndex}, path: ${imagePath}`);
  
  const imgElement = document.getElementById(`note-img-${noteId}`);
  const counterElement = document.querySelector(`[data-note-id="${noteId}"] .image-counter`);
  
  if (!imgElement) {
    console.error(`[ImageRotation] Image element not found: note-img-${noteId}`);
    return;
  }
  
  console.log(`[ImageRotation] Found image element for note ${noteId}`);
  
  const displayPath = convertImagePathForDisplay(imagePath);
  console.log(`[ImageRotation] Display path: ${displayPath}`);
  
  if (displayPath) {
    imgElement.src = displayPath;
    console.log(`[ImageRotation] Image src updated to: ${displayPath}`);
    
    // Update content-uri and image-path attributes if needed
    if (imagePath.startsWith('content://')) {
      imgElement.setAttribute('data-content-uri', imagePath);
      console.log(`[ImageRotation] Set content-uri attribute`);
    } else if (imagePath.startsWith('/storage/') || imagePath.startsWith('/sdcard/')) {
      imgElement.setAttribute('data-image-path', imagePath);
      console.log(`[ImageRotation] Set image-path attribute`);
    }
  } else {
    console.error(`[ImageRotation] No display path available for: ${imagePath}`);
  }
  
  // Update counter
  if (counterElement) {
    const note = allNotes.find(n => n.id === noteId);
    if (note && note.images) {
      const counterText = `${currentIndex + 1} / ${note.images.length}`;
      counterElement.textContent = counterText;
      console.log(`[ImageRotation] Counter updated to: ${counterText}`);
    }
  } else {
    console.warn(`[ImageRotation] Counter element not found for note ${noteId}`);
  }
}

// Start auto-rotation for all notes with multiple images
function startAllImageRotations() {
  console.log(`[ImageRotation] Starting auto-rotation for all notes`);
  console.log(`[ImageRotation] Total filtered notes: ${filteredNotes.length}`);
  
  // Clear all existing intervals
  Object.keys(imageRotationIntervals).forEach(noteId => {
    console.log(`[ImageRotation] Clearing existing interval for note ${noteId}`);
    stopImageRotation(noteId);
  });
  
  // Count notes with multiple images
  let multiImageCount = 0;
  
  // Start rotation for notes with multiple images
  filteredNotes.forEach(note => {
    if (note.images && note.images.length > 1) {
      multiImageCount++;
      console.log(`[ImageRotation] Note ${note.id} has ${note.images.length} images - starting rotation`);
      startImageRotation(note.id);
    } else {
      console.log(`[ImageRotation] Note ${note.id} has ${note.images ? note.images.length : 0} images - skipping rotation`);
    }
  });
  
  console.log(`[ImageRotation] Started auto-rotation for ${multiImageCount} notes with multiple images`);
  console.log(`[ImageRotation] Active intervals:`, Object.keys(imageRotationIntervals));
}

// Stop all image rotations
function stopAllImageRotations() {
  console.log(`[ImageRotation] Stopping all image rotations`);
  const intervalCount = Object.keys(imageRotationIntervals).length;
  Object.keys(imageRotationIntervals).forEach(noteId => {
    stopImageRotation(noteId);
  });
  console.log(`[ImageRotation] Stopped ${intervalCount} rotation intervals`);
}

// ========== END IMAGE ROTATION FUNCTIONS ==========

// ========== EDIT NOTE FUNCTIONS ==========

// Open edit modal
function openEditModal(noteId) {
  console.log('[Edit] Opening edit modal for note:', noteId);
  
  // Find the note - convert noteId to number if needed
  const note = allNotes.find(n => String(n.id) === String(noteId));
  
  if (!note) {
    console.error('[Edit] Note not found:', noteId);
    console.log('[Edit] Available notes:', allNotes.map(n => n.id));
    alert('Note not found. Please refresh and try again.');
    return;
  }
  
  console.log('[Edit] Found note:', note);
  
  // Populate the form
  document.getElementById('editNoteId').value = note.id;
  document.getElementById('editNoteTitle').value = note.title || '';
  document.getElementById('editNoteDescription').value = note.description || '';
  document.getElementById('editNoteDone').checked = note.done === true;
  
  // Show the modal
  const modal = document.getElementById('editModal');
  modal.classList.add('show');
  
  // Close any open menus
  document.querySelectorAll('.edit-menu').forEach(menu => menu.remove());
}

// Close edit modal
function closeEditModal() {
  const modal = document.getElementById('editModal');
  modal.classList.remove('show');
}

// Save note changes
function saveNoteChanges() {
  const noteId = document.getElementById('editNoteId').value;
  const title = document.getElementById('editNoteTitle').value.trim();
  const description = document.getElementById('editNoteDescription').value.trim();
  const done = document.getElementById('editNoteDone').checked;
  
  if (!title) {
    alert('Please enter a title for the note');
    return;
  }
  
  console.log('[Edit] Saving changes for note:', noteId);
  console.log('[Edit] New values:', { title, description, done });
  
  // Send update via WebSocket
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'update_note',
      noteId: noteId,
      updates: {
        title: title,
        description: description,
        done: done
      }
    };
    
    console.log('[Edit] Sending update message:', message);
    ws.send(JSON.stringify(message));
    
    // Close modal
    closeEditModal();
    
    // Show feedback
    showToast('üíæ Saving changes...');
    
    // Refresh notes after a short delay
    setTimeout(() => {
      loadNotes();
    }, 500);
  } else {
    console.error('[Edit] WebSocket not available');
    alert('Cannot save changes - connection issue. Please try again.');
  }
}

// Toggle note done status
function toggleNoteDone(noteId) {
  console.log('[Toggle] Toggling done status for note:', noteId);
  
  // Close any open menus
  document.querySelectorAll('.edit-menu').forEach(menu => menu.remove());
  
  // Find the note
  const note = allNotes.find(n => String(n.id) === String(noteId));
  
  if (!note) {
    console.error('[Toggle] Note not found:', noteId);
    return;
  }
  
  console.log('[Toggle] Current note state:', { id: note.id, done: note.done });
  
  // Send direct update_note message with proper noteId
  if (ws && ws.readyState === WebSocket.OPEN) {
    const newDoneState = !note.done;
    console.log('[Toggle] Sending update_note with noteId:', noteId, 'done:', newDoneState);
    
    ws.send(JSON.stringify({
      type: 'update_note',
      noteId: String(noteId),  // Ensure it's a string
      updates: { done: newDoneState }
    }));
  } else {
    console.error('[Toggle] WebSocket not ready');
  }
}

// Delete note
function deleteNote(noteId) {
  console.log('[Delete] Deleting note:', noteId);
  
  // Close any open menus
  document.querySelectorAll('.edit-menu').forEach(menu => menu.remove());
  
  // Find the note
  const note = allNotes.find(n => String(n.id) === String(noteId));
  
  if (!note) {
    console.error('[Delete] Note not found:', noteId);
    return;
  }
  
  // Send chat command instead of direct WebSocket message
  // This ensures auto-confirm setting is respected
  if (ws && ws.readyState === WebSocket.OPEN) {
    // First, set the context by finding the note
    ws.send(JSON.stringify({
      type: 'chat',
      text: `/findbyid ${noteId}`
    }));
    
    // Then send the delete command after a short delay
    setTimeout(() => {
      ws.send(JSON.stringify({
        type: 'chat',
        text: '/delete'
      }));
    }, 100);
  }
}

// ========== END EDIT NOTE FUNCTIONS ==========

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  console.log('[Init] DOM Content Loaded');
  initializeWebSocket();
  setupEventListeners();
  loadNotes();
});

// WebSocket initialization
function initializeWebSocket() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  // Use localhost as fallback if hostname is empty (DroidScript case)
  const hostname = window.location.hostname || 'localhost';
  const wsUrl = `${protocol}//${hostname}:30000`;
  
  console.log('Connecting to WebSocket:', wsUrl);
  ws = new WebSocket(wsUrl);
  
  ws.onopen = function() {
    console.log('Connected to WebSocket');
    // Request all notes
    ws.send(JSON.stringify({ type: "get_all_notes" }));
  };
  
  ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    handleWebSocketMessage(data);
  };
  
  ws.onclose = function() {
    console.log('WebSocket connection closed');
    // Try to reconnect after 3 seconds
    setTimeout(initializeWebSocket, 3000);
  };
  
  ws.onerror = function(error) {
    console.error('WebSocket error:', error);
  };
}

// Handle WebSocket messages
function handleWebSocketMessage(data) {
  switch(data.type) {
    case 'all_notes':
      allNotes = validateNoteImages(data.notes || []);
      applyCurrentFilter();
      renderNotes();
      break;
    case 'note_updated':
      // Refresh notes when a note is updated
      loadNotes();
      break;
    case 'uri_conversion_success':
      handleUriConversionSuccess(data);
      break;
    case 'uri_conversion_error':
      break;
    case 'image_data':
      handleImageDataReceived(data);
      break;
    case 'image_url':
      handleImageUrlReceived(data);
      break;
    case 'image_error':
      handleImageError(data);
      break;
    case 'file_api_test_results':
      console.log('File API Test Results:', JSON.stringify(data.results, null, 2));
      break;
    case 'cleanup_complete':
      showToast('‚úÖ Broken image link removed');
      // Refresh the notes to show updated state
      loadNotes();
      break;
    case 'note_created':
      // Refresh notes when a new note is created
      loadNotes();
      break;
    case 'note_deleted':
      // Refresh notes when a note is deleted
      loadNotes();
      break;
  }
}

// Setup event listeners
function setupEventListeners() {
  console.log('[Setup] Setting up event listeners');
  
  // Side menu
  menuBtn.onclick = () => {
    console.log('[Menu] Menu button clicked');
    sideMenu.classList.add("open");
    overlay.classList.add("show");
    console.log('[Menu] Side menu should be open now');
  };
  
  closeMenu.onclick = () => {
    console.log('[Menu] Close button clicked');
    sideMenu.classList.remove("open");
    overlay.classList.remove("show");
  };
  
  overlay.onclick = () => {
    console.log('[Menu] Overlay clicked');
    sideMenu.classList.remove("open");
    overlay.classList.remove("show");
  };
  
  // Navigation
  chatButton.onclick = () => {
    console.log('[Nav] Chat button clicked');
    window.location.href = 'index.html';
  };
  
  explorerButton.onclick = () => {
    console.log('[Nav] Explorer button clicked');
    // Already on explorer page
    sideMenu.classList.remove("open");
    overlay.classList.remove("show");
  };
  
  // Search
  searchInput.addEventListener('input', function() {
    applyCurrentFilter();
    renderNotes();
  });
  
  // Refresh
  refreshBtn.onclick = () => {
    loadNotes();
  };
  
  // Filters
  showAllBtn.onclick = () => setFilter('all');
  showCompletedBtn.onclick = () => setFilter('completed');
  showPendingBtn.onclick = () => setFilter('pending');
}

// Set filter
function setFilter(filter) {
  currentFilter = filter;
  
  // Update button states
  document.querySelectorAll('.nav-button').forEach(btn => btn.classList.remove('active'));
  if (filter === 'all') showAllBtn.classList.add('active');
  else if (filter === 'completed') showCompletedBtn.classList.add('active');
  else if (filter === 'pending') showPendingBtn.classList.add('active');
  
  applyCurrentFilter();
  renderNotes();
}

// Apply current filter
function applyCurrentFilter() {
  const searchTerm = searchInput.value.toLowerCase();
  
  filteredNotes = allNotes.filter(note => {
    // Search filter
    const matchesSearch = !searchTerm || 
      note.title.toLowerCase().includes(searchTerm) ||
      (note.description && note.description.toLowerCase().includes(searchTerm));
    
    // Status filter
    let matchesStatus = true;
    if (currentFilter === 'completed') {
      matchesStatus = note.done === true;
    } else if (currentFilter === 'pending') {
      matchesStatus = note.done !== true;
    }
    
    // Don't show deleted notes
    const notDeleted = !note.deleted;
    
    return matchesSearch && matchesStatus && notDeleted;
  });
  
  // Check for notes with images
  const notesWithImages = filteredNotes.filter(note => note.images && note.images.length > 0);
}

// Load notes
function loadNotes() {
  loadingState.style.display = 'block';
  emptyState.style.display = 'none';
  notesGrid.style.display = 'none';
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "get_all_notes" }));
  } else {
    // If WebSocket is not ready, show empty state
    setTimeout(() => {
      loadingState.style.display = 'none';
      emptyState.style.display = 'block';
    }, 1000);
  }
}

// Validate and clean up missing images
        function validateNoteImages(notes) {
          // With file path storage approach, we don't validate image existence in the web interface
          // Images are stored as file paths and displayed as placeholders
          return notes.map(note => {
            return note;
          });
        }

// Render notes (updated to start auto-rotation)
function renderNotes() {
  console.log('[Render] Starting to render notes');
  console.log('[Render] Filtered notes count:', filteredNotes.length);
  
  loadingState.style.display = 'none';
  
  if (filteredNotes.length === 0) {
    console.log('[Render] No notes to display');
    emptyState.style.display = 'block';
    notesGrid.style.display = 'none';
    stopAllImageRotations();
    return;
  }
  
  emptyState.style.display = 'none';
  notesGrid.style.display = 'grid';
  
  // Sort notes by creation date (newest first)
  const sortedNotes = [...filteredNotes].sort((a, b) => {
    const dateA = new Date(a.creation_date || 0);
    const dateB = new Date(b.creation_date || 0);
    return dateB - dateA;
  });
  
  console.log('[Render] Sorted notes:', sortedNotes.length);
  
  notesGrid.innerHTML = sortedNotes.map(note => createNoteCard(note)).join('');
  console.log('[Render] Note cards created and inserted into DOM');
  
  // Start auto-rotation for notes with multiple images
  setTimeout(() => {
    console.log('[Render] Starting auto-rotation after 500ms delay');
    startAllImageRotations();
  }, 500); // Small delay to ensure DOM is ready
}

// Create note card HTML (updated with better logging)
function createNoteCard(note) {
  const isCompleted = note.done === true;
  const isParent = !note.parent_id;
  const hasSubNotes = note.subNotes && note.subNotes.length > 0;
  const subNotesCount = hasSubNotes ? note.subNotes.length : 0;
  const hasImages = note.images && note.images.length > 0;
  const imageCount = hasImages ? note.images.length : 0;
  
  console.log(`[CreateCard] Creating card for note ${note.id}, images: ${imageCount}`);
  
  const statusText = isCompleted ? 'Completed' : 'Pending';
  const statusClass = isCompleted ? 'completed' : 'pending';
  
  const createdAt = note.creation_date ? new Date(note.creation_date).toLocaleDateString() : 'Unknown';
  
  // Generate image preview HTML
  let imagePreviewHtml = '';
  if (hasImages) {
    const firstImage = note.images[0];
    const displayPath = convertImagePathForDisplay(firstImage);
    
    if (displayPath) {
      const contentUriAttr = firstImage.startsWith('content://') ? `data-content-uri="${firstImage}"` : '';
      const imagePathAttr = (firstImage.startsWith('/storage/') || firstImage.startsWith('/sdcard/')) ? 
        `data-image-path="${firstImage}"` : '';
      
      if (imageCount === 1) {
        imagePreviewHtml = `
          <div class="note-images" data-note-id="${note.id}">
            <div class="image-preview-container">
              <img class="image-preview-img" src="${displayPath}" alt="Note image" ${contentUriAttr} ${imagePathAttr}
                   onerror="this.parentElement.innerHTML='<div class='image-error'>üì∑ Image not found<br><small>Click to manage</small></div>'"
                   onclick="showImageManagement('${note.id}')">
            </div>
          </div>
        `;
      } else {
        imagePreviewHtml = `
          <div class="note-images" data-note-id="${note.id}">
            <div class="image-preview-container">
              <img class="image-preview-img" id="note-img-${note.id}" src="${displayPath}" alt="Note image" ${contentUriAttr} ${imagePathAttr}
                   onerror="this.parentElement.innerHTML='<div class='image-error'>üì∑ ${imageCount} images attached<br><small>Click to manage</small></div>'"
                   onclick="showImageManagement('${note.id}')">
              <div class="image-counter">1 / ${imageCount}</div>
              <button class="nav-btn prev-btn" onclick="event.stopPropagation(); rotateImage('${note.id}', -1)">&#10094;</button>
              <button class="nav-btn next-btn" onclick="event.stopPropagation(); rotateImage('${note.id}', 1)">&#10095;</button>
            </div>
          </div>
        `;
      }
    } else {
      imagePreviewHtml = `
        <div class="note-images" onclick="showImageManagement('${note.id}')">
          <div class="image-preview image-placeholder">
            üì∑ ${imageCount} image${imageCount > 1 ? 's' : ''} attached<br>
            <small style="font-size: 12px; opacity: 0.7;">Click to manage images</small>
          </div>
        </div>
      `;
    }
  }
  
  return `
    <div class="note-card ${isCompleted ? 'completed' : ''}" data-note-id="${note.id}">
      <div class="note-header">
        <div class="note-title">${escapeHtml(note.title)}</div>
        <div class="note-actions">
          ${isParent ? '<span class="parent-indicator" title="Parent Note">P</span>' : ''}
          <button class="note-menu-btn" data-note-id="${note.id}" title="More actions">‚ãØ</button>
        </div>
      </div>
      ${note.description ? `<div class="note-description">${escapeHtml(note.description)}</div>` : ''}
      ${imagePreviewHtml}
      ${hasSubNotes ? `<div class="sub-notes">üìù <span class="sub-notes-count">${subNotesCount}</span> sub-notes</div>` : ''}
      <div class="note-meta">
        <span class="note-id">#${note.id}</span>
        <span class="note-date">${createdAt}</span>
        <span class="note-status ${statusClass}">${statusText}</span>
      </div>
    </div>
  `;
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Convert image path for display in web browser
function convertImagePathForDisplay(imagePath) {
  if (!imagePath) {
    return null;
  }
  
  // Handle content:// URIs - request conversion via WebSocket
  if (imagePath.startsWith('content://')) {
    requestContentUriConversion(imagePath);
    // Return a placeholder that will be updated via WebSocket
    const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzJhMmYzNiIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjYTBhMGEwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+TG9hZGluZy4uLjwvdGV4dD48L3N2Zz4=';
    return placeholder;
  }
  
  // Handle internal storage paths (from new system) - these should work!
  if (imagePath.includes('/files/images/') || imagePath.includes('/data/data/')) {
    console.log('‚úÖ Internal storage path detected:', imagePath);
    requestImageViaWebSocket(imagePath);
    // Return a placeholder that will be updated when image data arrives
    const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzAwODA0MCIvPjx0ZXh0IHg9IjUwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+SW50ZXJuYWw8L3RleHQ+PHRleHQgeD0iNTAiIHk9IjYwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IndoaXRlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5Mb2FkaW5nLi4uPC90ZXh0Pjwvc3ZnPg==';
    return placeholder;
  }
  
  // Handle external storage paths - these may have permission issues
  if (imagePath.startsWith('/storage/') || imagePath.startsWith('/sdcard/')) {
    console.log('‚ö†Ô∏è External storage path detected (may have permission issues):', imagePath);
    requestImageViaWebSocket(imagePath);
    // Return a placeholder that will be updated when image data arrives
    const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2ZmYTUwMCIvPjx0ZXh0IHg9IjUwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+UGVybWlzc2lvbjwvdGV4dD48dGV4dCB4PSI1MCIgeT0iNjAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPklzc3VlPC90ZXh0Pjwvc3ZnPg==';
    return placeholder;
  }
  
  // Handle relative paths (legacy and new)
  if (!imagePath.startsWith('/') && !imagePath.startsWith('http')) {
    // If it's an old path with "images/", remove it.
    if (imagePath.startsWith('images/')) {
        imagePath = imagePath.substring('images/'.length);
    }
    return `/image/${imagePath}`;
  }
  
  return imagePath;
}

// Request content URI conversion via WebSocket
function requestContentUriConversion(contentUri) {
  console.log('DEBUG: requestContentUriConversion called with:', contentUri);
  console.log('DEBUG: WebSocket state:', ws ? ws.readyState : 'WebSocket is null');
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    console.log('DEBUG: Sending content URI conversion request via WebSocket');
    const message = {
      type: 'convert_content_uri',
      contentUri: contentUri
    };
    console.log('DEBUG: WebSocket message:', JSON.stringify(message));
    ws.send(JSON.stringify(message));
  } else {
    console.log('DEBUG: WebSocket not available for URI conversion - state:', ws ? ws.readyState : 'null');
  }
}

// Request image data via WebSocket
function requestImageViaWebSocket(imagePath) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    const requestId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const message = {
      type: 'request_image',
      imagePath: imagePath,
      requestId: requestId
    };
    ws.send(JSON.stringify(message));
  }
}

// Handle successful URI conversion
function handleUriConversionSuccess(data) {
  console.log('DEBUG: URI conversion successful:', data.contentUri, '->', data.filePath);
  
  // Find all image elements that need updating
  const imageElements = document.querySelectorAll(`img[data-content-uri="${data.contentUri}"]`);
  
  imageElements.forEach(img => {
    // Request the converted image via WebSocket instead of HTTP
    console.log('DEBUG: Requesting converted image via WebSocket:', data.filePath);
    requestImageViaWebSocket(data.filePath);
    img.removeAttribute('data-content-uri');
    // Add a data attribute to track this image for when the data arrives
    img.setAttribute('data-image-path', data.filePath);
  });
}

// Handle image data received via WebSocket
function handleImageDataReceived(data) {
  // Find all image elements that are waiting for this image path
  // Check both data-image-path and data-content-uri attributes
  const imageElements = document.querySelectorAll(`img[data-image-path="${data.imagePath}"], img[data-content-uri="${data.imagePath}"]`);
  
  imageElements.forEach(img => {
    // Create data URL from base64 data
    const dataUrl = `data:${data.contentType};base64,${data.data}`;
    img.src = dataUrl;
    img.removeAttribute('data-image-path');
    img.removeAttribute('data-content-uri');
    console.log('Successfully loaded image from content URI:', data.imagePath);
  });
}

function handleImageUrlReceived(data) {
  console.log('DEBUG: Received image URL:', data.imageUrl, 'for path:', data.imagePath);
  
  // Find all image elements that are waiting for this image path
  const imageElements = document.querySelectorAll(`img[data-image-path="${data.imagePath}"], img[data-content-uri="${data.imagePath}"]`);
  
  imageElements.forEach(img => {
    // Use the HTTP URL directly
    img.src = data.imageUrl;
    img.removeAttribute('data-image-path');
    img.removeAttribute('data-content-uri');
    console.log('‚úÖ Successfully set HTTP image URL:', data.imageUrl);
  });
}

        // Handle image error received via WebSocket
        function handleImageError(data) {
          
          // Find all image elements that are waiting for this image path
          const imageElements = document.querySelectorAll(`img[data-image-path="${data.imagePath}"]`);
          
          imageElements.forEach(img => {
            // Determine error type and show appropriate message
            let errorMessage = "‚ùå Image Not Accessible";
            let errorDetail = "Permission or file access issue";
            
            if (data.error.includes("Permission Denial")) {
              errorMessage = "üîí Permission Issue";
              errorDetail = "Android storage restrictions prevent access";
            } else if (data.error.includes("not found") || data.error.includes("file not found")) {
              errorMessage = "üìÅ File Missing";
              errorDetail = "Original file may have been moved or deleted";
            }
            
            // Show error placeholder with cleanup option
            img.parentElement.innerHTML = `
              <div class="image-error" onclick="cleanupBrokenImage('${data.imagePath}')">
                ${errorMessage}<br>
                <small>${errorDetail}</small><br>
                <small style="color: #888; margin-top: 4px;">Click to remove from note</small>
              </div>`;
          });
        }
        
        // Clean up broken image from note
        function cleanupBrokenImage(imagePath) {
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            const message = {
              type: 'cleanup_broken_image',
              imagePath: imagePath
            };
            console.log('DEBUG: Sending cleanup request:', JSON.stringify(message));
            ws.send(JSON.stringify(message));
            
            // Show feedback
            showToast('üßπ Removing broken image link...');
          } else {
            console.log('DEBUG: WebSocket not available for cleanup');
            showToast('‚ùå Cannot remove image - connection issue');
          }
        }
        
        // Simple toast notification
        function showToast(message) {
          // Create toast element
          const toast = document.createElement('div');
          toast.className = 'toast';
          toast.textContent = message;
          toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1d21;
            color: #e6e6e6;
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 3000;
            font-size: 14px;`;
          
          document.body.appendChild(toast);
          
          // Remove toast after 3 seconds
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 3000);
        }

// Show edit menu for a note
function showEditMenu(noteId, event) {
  event.stopPropagation();
  event.preventDefault();
  console.log('[EditMenu] Showing menu for note:', noteId, 'type:', typeof noteId);
  
  // Close any existing menus
  document.querySelectorAll('.edit-menu').forEach(menu => menu.remove());
  
  // Find note using string comparison to handle type mismatches
  const note = allNotes.find(n => String(n.id) === String(noteId));
  
  if (!note) {
    console.error('[EditMenu] Note not found:', noteId);
    console.error('[EditMenu] Available note IDs:', allNotes.map(n => `${n.id} (${typeof n.id})`));
    return;
  }
  
  console.log('[EditMenu] Found note:', note.title);
  
  // Create menu
  const menu = document.createElement('div');
  menu.className = 'edit-menu';
  
  // Edit option
  const editItem = document.createElement('div');
  editItem.className = 'edit-menu-item';
  editItem.innerHTML = '‚úèÔ∏è Edit Note';
  editItem.onclick = (e) => {
    e.stopPropagation();
    console.log('[EditMenu] Edit clicked for note:', noteId);
    openEditModal(noteId);
  };
  menu.appendChild(editItem);
  
  // Toggle done status
  const toggleItem = document.createElement('div');
  toggleItem.className = 'edit-menu-item';
  toggleItem.innerHTML = note.done ? '‚è≥ Mark as Pending' : '‚úÖ Mark as Done';
  toggleItem.onclick = (e) => {
    e.stopPropagation();
    toggleNoteDone(noteId);
  };
  menu.appendChild(toggleItem);
  
  // Delete option
  const deleteItem = document.createElement('div');
  deleteItem.className = 'edit-menu-item danger';
  deleteItem.innerHTML = 'üóëÔ∏è Delete Note';
  deleteItem.onclick = (e) => {
    e.stopPropagation();
    deleteNote(noteId);
  };
  menu.appendChild(deleteItem);
  
  // Position and show menu - use event.target instead of event.currentTarget
  const button = event.target.closest('.note-menu-btn') || event.target;
  const rect = button.getBoundingClientRect();
  menu.style.position = 'fixed';
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.right = `${window.innerWidth - rect.right}px`;
  
  document.body.appendChild(menu);
  
  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeMenuHandler(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenuHandler);
      }
    });
  }, 0);
}

// Handle note card clicks - UPDATED with more debug logs
document.addEventListener('click', function(e) {
  // Check if it's a menu button click
  if (e.target.classList.contains('note-menu-btn')) {
    console.log('[Click] ========== MENU BUTTON CLICKED ==========');
    console.log('[Click] Menu button clicked');
    console.log('[Click] Target element:', e.target);
    console.log('[Click] data-note-id attribute:', e.target.getAttribute('data-note-id'));
    console.log('[Click] data-note-id type:', typeof e.target.getAttribute('data-note-id'));
    
    e.stopPropagation();
    e.preventDefault();
    
    const noteIdAttr = e.target.getAttribute('data-note-id');
    console.log('[Click] Raw noteId from attribute:', noteIdAttr);
    
    const noteId = parseInt(noteIdAttr);
    console.log('[Click] Parsed noteId:', noteId);
    console.log('[Click] Parsed noteId type:', typeof noteId);
    console.log('[Click] Is NaN?', isNaN(noteId));
    
    showEditMenu(noteId, e);
    return;
  }
  
  // Check if clicking inside edit menu
  if (e.target.closest('.edit-menu')) {
    console.log('[Click] Edit menu item clicked');
    return;
  }
  
  // Check if it's a note card click (but not on menu button or actions)
  const noteCard = e.target.closest('.note-card');
  if (noteCard && !e.target.closest('.note-actions') && !e.target.closest('.edit-menu')) {
    const noteId = noteCard.getAttribute('data-note-id');
    if (noteId) {
      console.log('[Click] Note card clicked, navigating to chat');
      // Navigate to chat and automatically execute /findbyid command
      window.location.href = `index.html?findbyid=${noteId}`;
    }
  }
});
</script>
</body>
</html>
